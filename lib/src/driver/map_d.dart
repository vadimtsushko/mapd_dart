/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
library mapd.src.map_d;

import 'dart:async';
import 'dart:typed_data' show Uint8List;
import 'package:mapd/src/thrift/thrift.dart';
import '../driver.dart';


abstract class MapD {

  Future<String> connect(String user, String passwd, String dbname);

  Future disconnect(String session);

  Future<TServerStatus> get_server_status(String session);

  Future<List<String>> get_tables(String session);

  Future<TTableDetails> get_table_details(String session, String table_name);

  Future<TTableDetails> get_internal_table_details(String session, String table_name);

  Future<List<String>> get_users(String session);

  Future<List<TDBInfo>> get_databases(String session);

  Future<String> get_version();

  Future start_heap_profile(String session);

  Future stop_heap_profile(String session);

  Future<String> get_heap_profile(String session);

  Future<String> get_memory_gpu(String session);

  Future<String> get_memory_cpu(String session);

  Future<TMemorySummary> get_memory_summary(String session);

  Future clear_cpu_memory(String session);

  Future clear_gpu_memory(String session);

  Future rollback_table_epoch(String session, int db_id, int table_id, int new_epoch);

  Future<TQueryResult> sql_execute(String session, String query, bool column_format, String nonce, int first_n);

  Future<TDataFrame> sql_execute_df(String session, String query, int device_type, int device_id, int first_n);

  Future<TDataFrame> sql_execute_gdf(String session, String query, int device_id, int first_n);

  Future interrupt(String session);

  Future<Map<String, TColumnType>> sql_validate(String session, String query);

  Future set_execution_mode(String session, int mode);

  Future<TRenderResult> render_vega(String session, int widget_id, String vega_json, int compression_level, String nonce);

  Future<TPixelTableRowResult> get_result_row_for_pixel(String session, int widget_id, TPixel pixel, Map<String, List<String>> table_col_names, bool column_format, int pixelRadius, String nonce);

  Future<TFrontendView> get_frontend_view(String session, String view_name);

  Future<List<TFrontendView>> get_frontend_views(String session);

  Future create_frontend_view(String session, String view_name, String view_state, String image_hash, String view_metadata);

  Future delete_frontend_view(String session, String view_name);

  Future<TFrontendView> get_link_view(String session, String link);

  Future<String> create_link(String session, String view_state, String view_metadata);

  Future load_table_binary(String session, String table_name, List<TRow> rows);

  Future load_table(String session, String table_name, List<TStringRow> rows);

  Future<TDetectResult> detect_column_types(String session, String file_name, TCopyParams copy_params);

  Future create_table(String session, String table_name, List<TColumnType> row_desc, int table_type);

  Future import_table(String session, String table_name, String file_name, TCopyParams copy_params);

  Future import_geo_table(String session, String table_name, String file_name, TCopyParams copy_params, List<TColumnType> row_desc);

  Future<TImportStatus> import_table_status(String session, String import_id);

  Future<TPendingQuery> start_query(String session, String query_ra, bool just_explain);

  Future<TStepResult> execute_first_step(TPendingQuery pending_query);

  Future broadcast_serialized_rows(String serialized_rows, List<TColumnType> row_desc, int query_id);

  Future<TRawPixelDataResult> render_vega_raw_pixels(String session, int widget_id, int node_idx, String vega_json);

  Future insert_data(String session, TInsertData insert_data);

  Future<Map<String, TColumnType>> get_table_descriptor(String session, String table_name);

  Future<List<TColumnType>> get_row_descriptor(String session, String table_name);

  Future<TRenderResult> render(String session, String query, String render_type, String nonce);

  Future<TPixelResult> get_rows_for_pixels(String session, int widget_id, List<TPixel> pixels, String table_name, List<String> col_names, bool column_format, String nonce);

  Future<TPixelRowResult> get_row_for_pixel(String session, int widget_id, TPixel pixel, String table_name, List<String> col_names, bool column_format, int pixelRadius, String nonce);
}

class MapDClient implements MapD {

  MapDClient(TProtocol iprot, [TProtocol oprot = null]) {
    _iprot = iprot;
    _oprot = (oprot == null) ? iprot : oprot;
  }

  TProtocol _iprot;

  TProtocol get iprot => _iprot;

  TProtocol _oprot;

  TProtocol get oprot => _oprot;

  int _seqid = 0;

  int get seqid => _seqid;

  int nextSeqid() => ++_seqid;

  Future<String> connect(String user, String passwd, String dbname) async {
    oprot.writeMessageBegin(new TMessage("connect", TMessageType.CALL, nextSeqid()));
    connect_args args = new connect_args();
    args.user = user;
    args.passwd = passwd;
    args.dbname = dbname;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    connect_result result = new connect_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "connect failed: unknown result");
  }

  Future disconnect(String session) async {
    oprot.writeMessageBegin(new TMessage("disconnect", TMessageType.CALL, nextSeqid()));
    disconnect_args args = new disconnect_args();
    args.session = session;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    disconnect_result result = new disconnect_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<TServerStatus> get_server_status(String session) async {
    oprot.writeMessageBegin(new TMessage("get_server_status", TMessageType.CALL, nextSeqid()));
    get_server_status_args args = new get_server_status_args();
    args.session = session;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    get_server_status_result result = new get_server_status_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "get_server_status failed: unknown result");
  }

  Future<List<String>> get_tables(String session) async {
    oprot.writeMessageBegin(new TMessage("get_tables", TMessageType.CALL, nextSeqid()));
    get_tables_args args = new get_tables_args();
    args.session = session;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    get_tables_result result = new get_tables_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "get_tables failed: unknown result");
  }

  Future<TTableDetails> get_table_details(String session, String table_name) async {
    oprot.writeMessageBegin(new TMessage("get_table_details", TMessageType.CALL, nextSeqid()));
    get_table_details_args args = new get_table_details_args();
    args.session = session;
    args.table_name = table_name;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    get_table_details_result result = new get_table_details_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "get_table_details failed: unknown result");
  }

  Future<TTableDetails> get_internal_table_details(String session, String table_name) async {
    oprot.writeMessageBegin(new TMessage("get_internal_table_details", TMessageType.CALL, nextSeqid()));
    get_internal_table_details_args args = new get_internal_table_details_args();
    args.session = session;
    args.table_name = table_name;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    get_internal_table_details_result result = new get_internal_table_details_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "get_internal_table_details failed: unknown result");
  }

  Future<List<String>> get_users(String session) async {
    oprot.writeMessageBegin(new TMessage("get_users", TMessageType.CALL, nextSeqid()));
    get_users_args args = new get_users_args();
    args.session = session;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    get_users_result result = new get_users_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "get_users failed: unknown result");
  }

  Future<List<TDBInfo>> get_databases(String session) async {
    oprot.writeMessageBegin(new TMessage("get_databases", TMessageType.CALL, nextSeqid()));
    get_databases_args args = new get_databases_args();
    args.session = session;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    get_databases_result result = new get_databases_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "get_databases failed: unknown result");
  }

  Future<String> get_version() async {
    oprot.writeMessageBegin(new TMessage("get_version", TMessageType.CALL, nextSeqid()));
    get_version_args args = new get_version_args();
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    get_version_result result = new get_version_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "get_version failed: unknown result");
  }

  Future start_heap_profile(String session) async {
    oprot.writeMessageBegin(new TMessage("start_heap_profile", TMessageType.CALL, nextSeqid()));
    start_heap_profile_args args = new start_heap_profile_args();
    args.session = session;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    start_heap_profile_result result = new start_heap_profile_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future stop_heap_profile(String session) async {
    oprot.writeMessageBegin(new TMessage("stop_heap_profile", TMessageType.CALL, nextSeqid()));
    stop_heap_profile_args args = new stop_heap_profile_args();
    args.session = session;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    stop_heap_profile_result result = new stop_heap_profile_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<String> get_heap_profile(String session) async {
    oprot.writeMessageBegin(new TMessage("get_heap_profile", TMessageType.CALL, nextSeqid()));
    get_heap_profile_args args = new get_heap_profile_args();
    args.session = session;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    get_heap_profile_result result = new get_heap_profile_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "get_heap_profile failed: unknown result");
  }

  Future<String> get_memory_gpu(String session) async {
    oprot.writeMessageBegin(new TMessage("get_memory_gpu", TMessageType.CALL, nextSeqid()));
    get_memory_gpu_args args = new get_memory_gpu_args();
    args.session = session;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    get_memory_gpu_result result = new get_memory_gpu_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "get_memory_gpu failed: unknown result");
  }

  Future<String> get_memory_cpu(String session) async {
    oprot.writeMessageBegin(new TMessage("get_memory_cpu", TMessageType.CALL, nextSeqid()));
    get_memory_cpu_args args = new get_memory_cpu_args();
    args.session = session;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    get_memory_cpu_result result = new get_memory_cpu_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "get_memory_cpu failed: unknown result");
  }

  Future<TMemorySummary> get_memory_summary(String session) async {
    oprot.writeMessageBegin(new TMessage("get_memory_summary", TMessageType.CALL, nextSeqid()));
    get_memory_summary_args args = new get_memory_summary_args();
    args.session = session;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    get_memory_summary_result result = new get_memory_summary_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "get_memory_summary failed: unknown result");
  }

  Future clear_cpu_memory(String session) async {
    oprot.writeMessageBegin(new TMessage("clear_cpu_memory", TMessageType.CALL, nextSeqid()));
    clear_cpu_memory_args args = new clear_cpu_memory_args();
    args.session = session;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    clear_cpu_memory_result result = new clear_cpu_memory_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future clear_gpu_memory(String session) async {
    oprot.writeMessageBegin(new TMessage("clear_gpu_memory", TMessageType.CALL, nextSeqid()));
    clear_gpu_memory_args args = new clear_gpu_memory_args();
    args.session = session;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    clear_gpu_memory_result result = new clear_gpu_memory_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future rollback_table_epoch(String session, int db_id, int table_id, int new_epoch) async {
    oprot.writeMessageBegin(new TMessage("rollback_table_epoch", TMessageType.CALL, nextSeqid()));
    rollback_table_epoch_args args = new rollback_table_epoch_args();
    args.session = session;
    args.db_id = db_id;
    args.table_id = table_id;
    args.new_epoch = new_epoch;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    rollback_table_epoch_result result = new rollback_table_epoch_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<TQueryResult> sql_execute(String session, String query, bool column_format, String nonce, int first_n) async {
    oprot.writeMessageBegin(new TMessage("sql_execute", TMessageType.CALL, nextSeqid()));
    sql_execute_args args = new sql_execute_args();
    args.session = session;
    args.query = query;
    args.column_format = column_format;
    args.nonce = nonce;
    args.first_n = first_n;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    sql_execute_result result = new sql_execute_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "sql_execute failed: unknown result");
  }

  Future<TDataFrame> sql_execute_df(String session, String query, int device_type, int device_id, int first_n) async {
    oprot.writeMessageBegin(new TMessage("sql_execute_df", TMessageType.CALL, nextSeqid()));
    sql_execute_df_args args = new sql_execute_df_args();
    args.session = session;
    args.query = query;
    args.device_type = device_type;
    args.device_id = device_id;
    args.first_n = first_n;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    sql_execute_df_result result = new sql_execute_df_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "sql_execute_df failed: unknown result");
  }

  Future<TDataFrame> sql_execute_gdf(String session, String query, int device_id, int first_n) async {
    oprot.writeMessageBegin(new TMessage("sql_execute_gdf", TMessageType.CALL, nextSeqid()));
    sql_execute_gdf_args args = new sql_execute_gdf_args();
    args.session = session;
    args.query = query;
    args.device_id = device_id;
    args.first_n = first_n;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    sql_execute_gdf_result result = new sql_execute_gdf_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "sql_execute_gdf failed: unknown result");
  }

  Future interrupt(String session) async {
    oprot.writeMessageBegin(new TMessage("interrupt", TMessageType.CALL, nextSeqid()));
    interrupt_args args = new interrupt_args();
    args.session = session;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    interrupt_result result = new interrupt_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<Map<String, TColumnType>> sql_validate(String session, String query) async {
    oprot.writeMessageBegin(new TMessage("sql_validate", TMessageType.CALL, nextSeqid()));
    sql_validate_args args = new sql_validate_args();
    args.session = session;
    args.query = query;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    sql_validate_result result = new sql_validate_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "sql_validate failed: unknown result");
  }

  Future set_execution_mode(String session, int mode) async {
    oprot.writeMessageBegin(new TMessage("set_execution_mode", TMessageType.CALL, nextSeqid()));
    set_execution_mode_args args = new set_execution_mode_args();
    args.session = session;
    args.mode = mode;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    set_execution_mode_result result = new set_execution_mode_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<TRenderResult> render_vega(String session, int widget_id, String vega_json, int compression_level, String nonce) async {
    oprot.writeMessageBegin(new TMessage("render_vega", TMessageType.CALL, nextSeqid()));
    render_vega_args args = new render_vega_args();
    args.session = session;
    args.widget_id = widget_id;
    args.vega_json = vega_json;
    args.compression_level = compression_level;
    args.nonce = nonce;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    render_vega_result result = new render_vega_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "render_vega failed: unknown result");
  }

  Future<TPixelTableRowResult> get_result_row_for_pixel(String session, int widget_id, TPixel pixel, Map<String, List<String>> table_col_names, bool column_format, int pixelRadius, String nonce) async {
    oprot.writeMessageBegin(new TMessage("get_result_row_for_pixel", TMessageType.CALL, nextSeqid()));
    get_result_row_for_pixel_args args = new get_result_row_for_pixel_args();
    args.session = session;
    args.widget_id = widget_id;
    args.pixel = pixel;
    args.table_col_names = table_col_names;
    args.column_format = column_format;
    args.pixelRadius = pixelRadius;
    args.nonce = nonce;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    get_result_row_for_pixel_result result = new get_result_row_for_pixel_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "get_result_row_for_pixel failed: unknown result");
  }

  Future<TFrontendView> get_frontend_view(String session, String view_name) async {
    oprot.writeMessageBegin(new TMessage("get_frontend_view", TMessageType.CALL, nextSeqid()));
    get_frontend_view_args args = new get_frontend_view_args();
    args.session = session;
    args.view_name = view_name;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    get_frontend_view_result result = new get_frontend_view_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "get_frontend_view failed: unknown result");
  }

  Future<List<TFrontendView>> get_frontend_views(String session) async {
    oprot.writeMessageBegin(new TMessage("get_frontend_views", TMessageType.CALL, nextSeqid()));
    get_frontend_views_args args = new get_frontend_views_args();
    args.session = session;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    get_frontend_views_result result = new get_frontend_views_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "get_frontend_views failed: unknown result");
  }

  Future create_frontend_view(String session, String view_name, String view_state, String image_hash, String view_metadata) async {
    oprot.writeMessageBegin(new TMessage("create_frontend_view", TMessageType.CALL, nextSeqid()));
    create_frontend_view_args args = new create_frontend_view_args();
    args.session = session;
    args.view_name = view_name;
    args.view_state = view_state;
    args.image_hash = image_hash;
    args.view_metadata = view_metadata;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    create_frontend_view_result result = new create_frontend_view_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future delete_frontend_view(String session, String view_name) async {
    oprot.writeMessageBegin(new TMessage("delete_frontend_view", TMessageType.CALL, nextSeqid()));
    delete_frontend_view_args args = new delete_frontend_view_args();
    args.session = session;
    args.view_name = view_name;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    delete_frontend_view_result result = new delete_frontend_view_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<TFrontendView> get_link_view(String session, String link) async {
    oprot.writeMessageBegin(new TMessage("get_link_view", TMessageType.CALL, nextSeqid()));
    get_link_view_args args = new get_link_view_args();
    args.session = session;
    args.link = link;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    get_link_view_result result = new get_link_view_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "get_link_view failed: unknown result");
  }

  Future<String> create_link(String session, String view_state, String view_metadata) async {
    oprot.writeMessageBegin(new TMessage("create_link", TMessageType.CALL, nextSeqid()));
    create_link_args args = new create_link_args();
    args.session = session;
    args.view_state = view_state;
    args.view_metadata = view_metadata;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    create_link_result result = new create_link_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "create_link failed: unknown result");
  }

  Future load_table_binary(String session, String table_name, List<TRow> rows) async {
    oprot.writeMessageBegin(new TMessage("load_table_binary", TMessageType.CALL, nextSeqid()));
    load_table_binary_args args = new load_table_binary_args();
    args.session = session;
    args.table_name = table_name;
    args.rows = rows;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    load_table_binary_result result = new load_table_binary_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future load_table(String session, String table_name, List<TStringRow> rows) async {
    oprot.writeMessageBegin(new TMessage("load_table", TMessageType.CALL, nextSeqid()));
    load_table_args args = new load_table_args();
    args.session = session;
    args.table_name = table_name;
    args.rows = rows;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    load_table_result result = new load_table_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<TDetectResult> detect_column_types(String session, String file_name, TCopyParams copy_params) async {
    oprot.writeMessageBegin(new TMessage("detect_column_types", TMessageType.CALL, nextSeqid()));
    detect_column_types_args args = new detect_column_types_args();
    args.session = session;
    args.file_name = file_name;
    args.copy_params = copy_params;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    detect_column_types_result result = new detect_column_types_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "detect_column_types failed: unknown result");
  }

  Future create_table(String session, String table_name, List<TColumnType> row_desc, int table_type) async {
    oprot.writeMessageBegin(new TMessage("create_table", TMessageType.CALL, nextSeqid()));
    create_table_args args = new create_table_args();
    args.session = session;
    args.table_name = table_name;
    args.row_desc = row_desc;
    args.table_type = table_type;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    create_table_result result = new create_table_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future import_table(String session, String table_name, String file_name, TCopyParams copy_params) async {
    oprot.writeMessageBegin(new TMessage("import_table", TMessageType.CALL, nextSeqid()));
    import_table_args args = new import_table_args();
    args.session = session;
    args.table_name = table_name;
    args.file_name = file_name;
    args.copy_params = copy_params;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    import_table_result result = new import_table_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future import_geo_table(String session, String table_name, String file_name, TCopyParams copy_params, List<TColumnType> row_desc) async {
    oprot.writeMessageBegin(new TMessage("import_geo_table", TMessageType.CALL, nextSeqid()));
    import_geo_table_args args = new import_geo_table_args();
    args.session = session;
    args.table_name = table_name;
    args.file_name = file_name;
    args.copy_params = copy_params;
    args.row_desc = row_desc;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    import_geo_table_result result = new import_geo_table_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<TImportStatus> import_table_status(String session, String import_id) async {
    oprot.writeMessageBegin(new TMessage("import_table_status", TMessageType.CALL, nextSeqid()));
    import_table_status_args args = new import_table_status_args();
    args.session = session;
    args.import_id = import_id;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    import_table_status_result result = new import_table_status_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "import_table_status failed: unknown result");
  }

  Future<TPendingQuery> start_query(String session, String query_ra, bool just_explain) async {
    oprot.writeMessageBegin(new TMessage("start_query", TMessageType.CALL, nextSeqid()));
    start_query_args args = new start_query_args();
    args.session = session;
    args.query_ra = query_ra;
    args.just_explain = just_explain;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    start_query_result result = new start_query_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "start_query failed: unknown result");
  }

  Future<TStepResult> execute_first_step(TPendingQuery pending_query) async {
    oprot.writeMessageBegin(new TMessage("execute_first_step", TMessageType.CALL, nextSeqid()));
    execute_first_step_args args = new execute_first_step_args();
    args.pending_query = pending_query;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    execute_first_step_result result = new execute_first_step_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "execute_first_step failed: unknown result");
  }

  Future broadcast_serialized_rows(String serialized_rows, List<TColumnType> row_desc, int query_id) async {
    oprot.writeMessageBegin(new TMessage("broadcast_serialized_rows", TMessageType.CALL, nextSeqid()));
    broadcast_serialized_rows_args args = new broadcast_serialized_rows_args();
    args.serialized_rows = serialized_rows;
    args.row_desc = row_desc;
    args.query_id = query_id;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    broadcast_serialized_rows_result result = new broadcast_serialized_rows_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<TRawPixelDataResult> render_vega_raw_pixels(String session, int widget_id, int node_idx, String vega_json) async {
    oprot.writeMessageBegin(new TMessage("render_vega_raw_pixels", TMessageType.CALL, nextSeqid()));
    render_vega_raw_pixels_args args = new render_vega_raw_pixels_args();
    args.session = session;
    args.widget_id = widget_id;
    args.node_idx = node_idx;
    args.vega_json = vega_json;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    render_vega_raw_pixels_result result = new render_vega_raw_pixels_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "render_vega_raw_pixels failed: unknown result");
  }

  Future insert_data(String session, TInsertData insert_data) async {
    oprot.writeMessageBegin(new TMessage("insert_data", TMessageType.CALL, nextSeqid()));
    insert_data_args args = new insert_data_args();
    args.session = session;
    args.insert_data = insert_data;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    insert_data_result result = new insert_data_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.e != null) {
      throw result.e;
    }
    return;
  }

  Future<Map<String, TColumnType>> get_table_descriptor(String session, String table_name) async {
    oprot.writeMessageBegin(new TMessage("get_table_descriptor", TMessageType.CALL, nextSeqid()));
    get_table_descriptor_args args = new get_table_descriptor_args();
    args.session = session;
    args.table_name = table_name;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    get_table_descriptor_result result = new get_table_descriptor_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "get_table_descriptor failed: unknown result");
  }

  Future<List<TColumnType>> get_row_descriptor(String session, String table_name) async {
    oprot.writeMessageBegin(new TMessage("get_row_descriptor", TMessageType.CALL, nextSeqid()));
    get_row_descriptor_args args = new get_row_descriptor_args();
    args.session = session;
    args.table_name = table_name;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    get_row_descriptor_result result = new get_row_descriptor_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "get_row_descriptor failed: unknown result");
  }

  Future<TRenderResult> render(String session, String query, String render_type, String nonce) async {
    oprot.writeMessageBegin(new TMessage("render", TMessageType.CALL, nextSeqid()));
    render_args args = new render_args();
    args.session = session;
    args.query = query;
    args.render_type = render_type;
    args.nonce = nonce;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    render_result result = new render_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "render failed: unknown result");
  }

  Future<TPixelResult> get_rows_for_pixels(String session, int widget_id, List<TPixel> pixels, String table_name, List<String> col_names, bool column_format, String nonce) async {
    oprot.writeMessageBegin(new TMessage("get_rows_for_pixels", TMessageType.CALL, nextSeqid()));
    get_rows_for_pixels_args args = new get_rows_for_pixels_args();
    args.session = session;
    args.widget_id = widget_id;
    args.pixels = pixels;
    args.table_name = table_name;
    args.col_names = col_names;
    args.column_format = column_format;
    args.nonce = nonce;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    get_rows_for_pixels_result result = new get_rows_for_pixels_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "get_rows_for_pixels failed: unknown result");
  }

  Future<TPixelRowResult> get_row_for_pixel(String session, int widget_id, TPixel pixel, String table_name, List<String> col_names, bool column_format, int pixelRadius, String nonce) async {
    oprot.writeMessageBegin(new TMessage("get_row_for_pixel", TMessageType.CALL, nextSeqid()));
    get_row_for_pixel_args args = new get_row_for_pixel_args();
    args.session = session;
    args.widget_id = widget_id;
    args.pixel = pixel;
    args.table_name = table_name;
    args.col_names = col_names;
    args.column_format = column_format;
    args.pixelRadius = pixelRadius;
    args.nonce = nonce;
    args.write(oprot);
    oprot.writeMessageEnd();

    await oprot.transport.flush();

    TMessage msg = iprot.readMessageBegin();
    if (msg.type == TMessageType.EXCEPTION) {
      TApplicationError error = TApplicationError.read(iprot);
      iprot.readMessageEnd();
      throw error;
    }

    get_row_for_pixel_result result = new get_row_for_pixel_result();
    result.read(iprot);
    iprot.readMessageEnd();
    if (result.isSetSuccess()) {
      return result.success;
    }

    if (result.e != null) {
      throw result.e;
    }
    throw new TApplicationError(TApplicationErrorType.MISSING_RESULT, "get_row_for_pixel failed: unknown result");
  }

}

typedef void ProcessFunction(int seqid, TProtocol iprot, TProtocol oprot);

class MapDProcessor implements TProcessor {
  MapDProcessor(MapD iface) {
    iface_ = iface;
    PROCESS_MAP["connect"] = connect;
    PROCESS_MAP["disconnect"] = disconnect;
    PROCESS_MAP["get_server_status"] = get_server_status;
    PROCESS_MAP["get_tables"] = get_tables;
    PROCESS_MAP["get_table_details"] = get_table_details;
    PROCESS_MAP["get_internal_table_details"] = get_internal_table_details;
    PROCESS_MAP["get_users"] = get_users;
    PROCESS_MAP["get_databases"] = get_databases;
    PROCESS_MAP["get_version"] = get_version;
    PROCESS_MAP["start_heap_profile"] = start_heap_profile;
    PROCESS_MAP["stop_heap_profile"] = stop_heap_profile;
    PROCESS_MAP["get_heap_profile"] = get_heap_profile;
    PROCESS_MAP["get_memory_gpu"] = get_memory_gpu;
    PROCESS_MAP["get_memory_cpu"] = get_memory_cpu;
    PROCESS_MAP["get_memory_summary"] = get_memory_summary;
    PROCESS_MAP["clear_cpu_memory"] = clear_cpu_memory;
    PROCESS_MAP["clear_gpu_memory"] = clear_gpu_memory;
    PROCESS_MAP["rollback_table_epoch"] = rollback_table_epoch;
    PROCESS_MAP["sql_execute"] = sql_execute;
    PROCESS_MAP["sql_execute_df"] = sql_execute_df;
    PROCESS_MAP["sql_execute_gdf"] = sql_execute_gdf;
    PROCESS_MAP["interrupt"] = interrupt;
    PROCESS_MAP["sql_validate"] = sql_validate;
    PROCESS_MAP["set_execution_mode"] = set_execution_mode;
    PROCESS_MAP["render_vega"] = render_vega;
    PROCESS_MAP["get_result_row_for_pixel"] = get_result_row_for_pixel;
    PROCESS_MAP["get_frontend_view"] = get_frontend_view;
    PROCESS_MAP["get_frontend_views"] = get_frontend_views;
    PROCESS_MAP["create_frontend_view"] = create_frontend_view;
    PROCESS_MAP["delete_frontend_view"] = delete_frontend_view;
    PROCESS_MAP["get_link_view"] = get_link_view;
    PROCESS_MAP["create_link"] = create_link;
    PROCESS_MAP["load_table_binary"] = load_table_binary;
    PROCESS_MAP["load_table"] = load_table;
    PROCESS_MAP["detect_column_types"] = detect_column_types;
    PROCESS_MAP["create_table"] = create_table;
    PROCESS_MAP["import_table"] = import_table;
    PROCESS_MAP["import_geo_table"] = import_geo_table;
    PROCESS_MAP["import_table_status"] = import_table_status;
    PROCESS_MAP["start_query"] = start_query;
    PROCESS_MAP["execute_first_step"] = execute_first_step;
    PROCESS_MAP["broadcast_serialized_rows"] = broadcast_serialized_rows;
    PROCESS_MAP["render_vega_raw_pixels"] = render_vega_raw_pixels;
    PROCESS_MAP["insert_data"] = insert_data;
    PROCESS_MAP["get_table_descriptor"] = get_table_descriptor;
    PROCESS_MAP["get_row_descriptor"] = get_row_descriptor;
    PROCESS_MAP["render"] = render;
    PROCESS_MAP["get_rows_for_pixels"] = get_rows_for_pixels;
    PROCESS_MAP["get_row_for_pixel"] = get_row_for_pixel;
  }

  MapD iface_;
  final Map<String, ProcessFunction> PROCESS_MAP = {};

  bool process(TProtocol iprot, TProtocol oprot) {
    TMessage msg = iprot.readMessageBegin();
    ProcessFunction fn = PROCESS_MAP[msg.name];
    if (fn == null) {
      TProtocolUtil.skip(iprot, TType.STRUCT);
      iprot.readMessageEnd();
      TApplicationError x = new TApplicationError(TApplicationErrorType.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
      oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return true;
    }
    fn(msg.seqid, iprot, oprot);
    return true;
  }

  connect(int seqid, TProtocol iprot, TProtocol oprot) async {
    connect_args args = new connect_args();
    args.read(iprot);
    iprot.readMessageEnd();
    connect_result result = new connect_result();
    try {
      result.success = await iface_.connect(args.user, args.passwd, args.dbname);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing connect");
      oprot.writeMessageBegin(new TMessage("connect", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("connect", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  disconnect(int seqid, TProtocol iprot, TProtocol oprot) {
    disconnect_args args = new disconnect_args();
    args.read(iprot);
    iprot.readMessageEnd();
    disconnect_result result = new disconnect_result();
    try {
      iface_.disconnect(args.session);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing disconnect");
      oprot.writeMessageBegin(new TMessage("disconnect", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("disconnect", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  get_server_status(int seqid, TProtocol iprot, TProtocol oprot) async {
    get_server_status_args args = new get_server_status_args();
    args.read(iprot);
    iprot.readMessageEnd();
    get_server_status_result result = new get_server_status_result();
    try {
      result.success = await iface_.get_server_status(args.session);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing get_server_status");
      oprot.writeMessageBegin(new TMessage("get_server_status", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("get_server_status", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  get_tables(int seqid, TProtocol iprot, TProtocol oprot) async {
    get_tables_args args = new get_tables_args();
    args.read(iprot);
    iprot.readMessageEnd();
    get_tables_result result = new get_tables_result();
    try {
      result.success = await iface_.get_tables(args.session);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing get_tables");
      oprot.writeMessageBegin(new TMessage("get_tables", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("get_tables", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  get_table_details(int seqid, TProtocol iprot, TProtocol oprot) async {
    get_table_details_args args = new get_table_details_args();
    args.read(iprot);
    iprot.readMessageEnd();
    get_table_details_result result = new get_table_details_result();
    try {
      result.success = await iface_.get_table_details(args.session, args.table_name);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing get_table_details");
      oprot.writeMessageBegin(new TMessage("get_table_details", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("get_table_details", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  get_internal_table_details(int seqid, TProtocol iprot, TProtocol oprot) async {
    get_internal_table_details_args args = new get_internal_table_details_args();
    args.read(iprot);
    iprot.readMessageEnd();
    get_internal_table_details_result result = new get_internal_table_details_result();
    try {
      result.success = await iface_.get_internal_table_details(args.session, args.table_name);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing get_internal_table_details");
      oprot.writeMessageBegin(new TMessage("get_internal_table_details", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("get_internal_table_details", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  get_users(int seqid, TProtocol iprot, TProtocol oprot) async {
    get_users_args args = new get_users_args();
    args.read(iprot);
    iprot.readMessageEnd();
    get_users_result result = new get_users_result();
    try {
      result.success = await iface_.get_users(args.session);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing get_users");
      oprot.writeMessageBegin(new TMessage("get_users", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("get_users", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  get_databases(int seqid, TProtocol iprot, TProtocol oprot) async {
    get_databases_args args = new get_databases_args();
    args.read(iprot);
    iprot.readMessageEnd();
    get_databases_result result = new get_databases_result();
    try {
      result.success = await iface_.get_databases(args.session);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing get_databases");
      oprot.writeMessageBegin(new TMessage("get_databases", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("get_databases", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  get_version(int seqid, TProtocol iprot, TProtocol oprot) async {
    get_version_args args = new get_version_args();
    args.read(iprot);
    iprot.readMessageEnd();
    get_version_result result = new get_version_result();
    try {
      result.success = await iface_.get_version();
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing get_version");
      oprot.writeMessageBegin(new TMessage("get_version", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("get_version", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  start_heap_profile(int seqid, TProtocol iprot, TProtocol oprot) {
    start_heap_profile_args args = new start_heap_profile_args();
    args.read(iprot);
    iprot.readMessageEnd();
    start_heap_profile_result result = new start_heap_profile_result();
    try {
      iface_.start_heap_profile(args.session);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing start_heap_profile");
      oprot.writeMessageBegin(new TMessage("start_heap_profile", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("start_heap_profile", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  stop_heap_profile(int seqid, TProtocol iprot, TProtocol oprot) {
    stop_heap_profile_args args = new stop_heap_profile_args();
    args.read(iprot);
    iprot.readMessageEnd();
    stop_heap_profile_result result = new stop_heap_profile_result();
    try {
      iface_.stop_heap_profile(args.session);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing stop_heap_profile");
      oprot.writeMessageBegin(new TMessage("stop_heap_profile", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("stop_heap_profile", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  get_heap_profile(int seqid, TProtocol iprot, TProtocol oprot) async {
    get_heap_profile_args args = new get_heap_profile_args();
    args.read(iprot);
    iprot.readMessageEnd();
    get_heap_profile_result result = new get_heap_profile_result();
    try {
      result.success = await iface_.get_heap_profile(args.session);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing get_heap_profile");
      oprot.writeMessageBegin(new TMessage("get_heap_profile", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("get_heap_profile", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  get_memory_gpu(int seqid, TProtocol iprot, TProtocol oprot) async {
    get_memory_gpu_args args = new get_memory_gpu_args();
    args.read(iprot);
    iprot.readMessageEnd();
    get_memory_gpu_result result = new get_memory_gpu_result();
    try {
      result.success = await iface_.get_memory_gpu(args.session);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing get_memory_gpu");
      oprot.writeMessageBegin(new TMessage("get_memory_gpu", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("get_memory_gpu", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  get_memory_cpu(int seqid, TProtocol iprot, TProtocol oprot) async {
    get_memory_cpu_args args = new get_memory_cpu_args();
    args.read(iprot);
    iprot.readMessageEnd();
    get_memory_cpu_result result = new get_memory_cpu_result();
    try {
      result.success = await iface_.get_memory_cpu(args.session);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing get_memory_cpu");
      oprot.writeMessageBegin(new TMessage("get_memory_cpu", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("get_memory_cpu", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  get_memory_summary(int seqid, TProtocol iprot, TProtocol oprot) async {
    get_memory_summary_args args = new get_memory_summary_args();
    args.read(iprot);
    iprot.readMessageEnd();
    get_memory_summary_result result = new get_memory_summary_result();
    try {
      result.success = await iface_.get_memory_summary(args.session);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing get_memory_summary");
      oprot.writeMessageBegin(new TMessage("get_memory_summary", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("get_memory_summary", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  clear_cpu_memory(int seqid, TProtocol iprot, TProtocol oprot) {
    clear_cpu_memory_args args = new clear_cpu_memory_args();
    args.read(iprot);
    iprot.readMessageEnd();
    clear_cpu_memory_result result = new clear_cpu_memory_result();
    try {
      iface_.clear_cpu_memory(args.session);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing clear_cpu_memory");
      oprot.writeMessageBegin(new TMessage("clear_cpu_memory", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("clear_cpu_memory", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  clear_gpu_memory(int seqid, TProtocol iprot, TProtocol oprot) {
    clear_gpu_memory_args args = new clear_gpu_memory_args();
    args.read(iprot);
    iprot.readMessageEnd();
    clear_gpu_memory_result result = new clear_gpu_memory_result();
    try {
      iface_.clear_gpu_memory(args.session);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing clear_gpu_memory");
      oprot.writeMessageBegin(new TMessage("clear_gpu_memory", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("clear_gpu_memory", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  rollback_table_epoch(int seqid, TProtocol iprot, TProtocol oprot) {
    rollback_table_epoch_args args = new rollback_table_epoch_args();
    args.read(iprot);
    iprot.readMessageEnd();
    rollback_table_epoch_result result = new rollback_table_epoch_result();
    try {
      iface_.rollback_table_epoch(args.session, args.db_id, args.table_id, args.new_epoch);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing rollback_table_epoch");
      oprot.writeMessageBegin(new TMessage("rollback_table_epoch", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("rollback_table_epoch", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  sql_execute(int seqid, TProtocol iprot, TProtocol oprot) async {
    sql_execute_args args = new sql_execute_args();
    args.read(iprot);
    iprot.readMessageEnd();
    sql_execute_result result = new sql_execute_result();
    try {
      result.success = await iface_.sql_execute(args.session, args.query, args.column_format, args.nonce, args.first_n);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing sql_execute");
      oprot.writeMessageBegin(new TMessage("sql_execute", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("sql_execute", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  sql_execute_df(int seqid, TProtocol iprot, TProtocol oprot) async {
    sql_execute_df_args args = new sql_execute_df_args();
    args.read(iprot);
    iprot.readMessageEnd();
    sql_execute_df_result result = new sql_execute_df_result();
    try {
      result.success = await iface_.sql_execute_df(args.session, args.query, args.device_type, args.device_id, args.first_n);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing sql_execute_df");
      oprot.writeMessageBegin(new TMessage("sql_execute_df", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("sql_execute_df", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  sql_execute_gdf(int seqid, TProtocol iprot, TProtocol oprot) async {
    sql_execute_gdf_args args = new sql_execute_gdf_args();
    args.read(iprot);
    iprot.readMessageEnd();
    sql_execute_gdf_result result = new sql_execute_gdf_result();
    try {
      result.success = await iface_.sql_execute_gdf(args.session, args.query, args.device_id, args.first_n);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing sql_execute_gdf");
      oprot.writeMessageBegin(new TMessage("sql_execute_gdf", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("sql_execute_gdf", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  interrupt(int seqid, TProtocol iprot, TProtocol oprot) {
    interrupt_args args = new interrupt_args();
    args.read(iprot);
    iprot.readMessageEnd();
    interrupt_result result = new interrupt_result();
    try {
      iface_.interrupt(args.session);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing interrupt");
      oprot.writeMessageBegin(new TMessage("interrupt", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("interrupt", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  sql_validate(int seqid, TProtocol iprot, TProtocol oprot) async {
    sql_validate_args args = new sql_validate_args();
    args.read(iprot);
    iprot.readMessageEnd();
    sql_validate_result result = new sql_validate_result();
    try {
      result.success = await iface_.sql_validate(args.session, args.query);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing sql_validate");
      oprot.writeMessageBegin(new TMessage("sql_validate", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("sql_validate", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  set_execution_mode(int seqid, TProtocol iprot, TProtocol oprot) {
    set_execution_mode_args args = new set_execution_mode_args();
    args.read(iprot);
    iprot.readMessageEnd();
    set_execution_mode_result result = new set_execution_mode_result();
    try {
      iface_.set_execution_mode(args.session, args.mode);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing set_execution_mode");
      oprot.writeMessageBegin(new TMessage("set_execution_mode", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("set_execution_mode", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  render_vega(int seqid, TProtocol iprot, TProtocol oprot) async {
    render_vega_args args = new render_vega_args();
    args.read(iprot);
    iprot.readMessageEnd();
    render_vega_result result = new render_vega_result();
    try {
      result.success = await iface_.render_vega(args.session, args.widget_id, args.vega_json, args.compression_level, args.nonce);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing render_vega");
      oprot.writeMessageBegin(new TMessage("render_vega", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("render_vega", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  get_result_row_for_pixel(int seqid, TProtocol iprot, TProtocol oprot) async {
    get_result_row_for_pixel_args args = new get_result_row_for_pixel_args();
    args.read(iprot);
    iprot.readMessageEnd();
    get_result_row_for_pixel_result result = new get_result_row_for_pixel_result();
    try {
      result.success = await iface_.get_result_row_for_pixel(args.session, args.widget_id, args.pixel, args.table_col_names, args.column_format, args.pixelRadius, args.nonce);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing get_result_row_for_pixel");
      oprot.writeMessageBegin(new TMessage("get_result_row_for_pixel", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("get_result_row_for_pixel", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  get_frontend_view(int seqid, TProtocol iprot, TProtocol oprot) async {
    get_frontend_view_args args = new get_frontend_view_args();
    args.read(iprot);
    iprot.readMessageEnd();
    get_frontend_view_result result = new get_frontend_view_result();
    try {
      result.success = await iface_.get_frontend_view(args.session, args.view_name);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing get_frontend_view");
      oprot.writeMessageBegin(new TMessage("get_frontend_view", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("get_frontend_view", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  get_frontend_views(int seqid, TProtocol iprot, TProtocol oprot) async {
    get_frontend_views_args args = new get_frontend_views_args();
    args.read(iprot);
    iprot.readMessageEnd();
    get_frontend_views_result result = new get_frontend_views_result();
    try {
      result.success = await iface_.get_frontend_views(args.session);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing get_frontend_views");
      oprot.writeMessageBegin(new TMessage("get_frontend_views", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("get_frontend_views", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  create_frontend_view(int seqid, TProtocol iprot, TProtocol oprot) {
    create_frontend_view_args args = new create_frontend_view_args();
    args.read(iprot);
    iprot.readMessageEnd();
    create_frontend_view_result result = new create_frontend_view_result();
    try {
      iface_.create_frontend_view(args.session, args.view_name, args.view_state, args.image_hash, args.view_metadata);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing create_frontend_view");
      oprot.writeMessageBegin(new TMessage("create_frontend_view", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("create_frontend_view", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  delete_frontend_view(int seqid, TProtocol iprot, TProtocol oprot) {
    delete_frontend_view_args args = new delete_frontend_view_args();
    args.read(iprot);
    iprot.readMessageEnd();
    delete_frontend_view_result result = new delete_frontend_view_result();
    try {
      iface_.delete_frontend_view(args.session, args.view_name);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing delete_frontend_view");
      oprot.writeMessageBegin(new TMessage("delete_frontend_view", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("delete_frontend_view", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  get_link_view(int seqid, TProtocol iprot, TProtocol oprot) async {
    get_link_view_args args = new get_link_view_args();
    args.read(iprot);
    iprot.readMessageEnd();
    get_link_view_result result = new get_link_view_result();
    try {
      result.success = await iface_.get_link_view(args.session, args.link);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing get_link_view");
      oprot.writeMessageBegin(new TMessage("get_link_view", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("get_link_view", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  create_link(int seqid, TProtocol iprot, TProtocol oprot) async {
    create_link_args args = new create_link_args();
    args.read(iprot);
    iprot.readMessageEnd();
    create_link_result result = new create_link_result();
    try {
      result.success = await iface_.create_link(args.session, args.view_state, args.view_metadata);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing create_link");
      oprot.writeMessageBegin(new TMessage("create_link", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("create_link", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  load_table_binary(int seqid, TProtocol iprot, TProtocol oprot) {
    load_table_binary_args args = new load_table_binary_args();
    args.read(iprot);
    iprot.readMessageEnd();
    load_table_binary_result result = new load_table_binary_result();
    try {
      iface_.load_table_binary(args.session, args.table_name, args.rows);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing load_table_binary");
      oprot.writeMessageBegin(new TMessage("load_table_binary", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("load_table_binary", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  load_table(int seqid, TProtocol iprot, TProtocol oprot) {
    load_table_args args = new load_table_args();
    args.read(iprot);
    iprot.readMessageEnd();
    load_table_result result = new load_table_result();
    try {
      iface_.load_table(args.session, args.table_name, args.rows);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing load_table");
      oprot.writeMessageBegin(new TMessage("load_table", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("load_table", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  detect_column_types(int seqid, TProtocol iprot, TProtocol oprot) async {
    detect_column_types_args args = new detect_column_types_args();
    args.read(iprot);
    iprot.readMessageEnd();
    detect_column_types_result result = new detect_column_types_result();
    try {
      result.success = await iface_.detect_column_types(args.session, args.file_name, args.copy_params);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing detect_column_types");
      oprot.writeMessageBegin(new TMessage("detect_column_types", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("detect_column_types", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  create_table(int seqid, TProtocol iprot, TProtocol oprot) {
    create_table_args args = new create_table_args();
    args.read(iprot);
    iprot.readMessageEnd();
    create_table_result result = new create_table_result();
    try {
      iface_.create_table(args.session, args.table_name, args.row_desc, args.table_type);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing create_table");
      oprot.writeMessageBegin(new TMessage("create_table", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("create_table", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  import_table(int seqid, TProtocol iprot, TProtocol oprot) {
    import_table_args args = new import_table_args();
    args.read(iprot);
    iprot.readMessageEnd();
    import_table_result result = new import_table_result();
    try {
      iface_.import_table(args.session, args.table_name, args.file_name, args.copy_params);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing import_table");
      oprot.writeMessageBegin(new TMessage("import_table", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("import_table", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  import_geo_table(int seqid, TProtocol iprot, TProtocol oprot) {
    import_geo_table_args args = new import_geo_table_args();
    args.read(iprot);
    iprot.readMessageEnd();
    import_geo_table_result result = new import_geo_table_result();
    try {
      iface_.import_geo_table(args.session, args.table_name, args.file_name, args.copy_params, args.row_desc);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing import_geo_table");
      oprot.writeMessageBegin(new TMessage("import_geo_table", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("import_geo_table", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  import_table_status(int seqid, TProtocol iprot, TProtocol oprot) async {
    import_table_status_args args = new import_table_status_args();
    args.read(iprot);
    iprot.readMessageEnd();
    import_table_status_result result = new import_table_status_result();
    try {
      result.success = await iface_.import_table_status(args.session, args.import_id);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing import_table_status");
      oprot.writeMessageBegin(new TMessage("import_table_status", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("import_table_status", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  start_query(int seqid, TProtocol iprot, TProtocol oprot) async {
    start_query_args args = new start_query_args();
    args.read(iprot);
    iprot.readMessageEnd();
    start_query_result result = new start_query_result();
    try {
      result.success = await iface_.start_query(args.session, args.query_ra, args.just_explain);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing start_query");
      oprot.writeMessageBegin(new TMessage("start_query", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("start_query", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  execute_first_step(int seqid, TProtocol iprot, TProtocol oprot) async {
    execute_first_step_args args = new execute_first_step_args();
    args.read(iprot);
    iprot.readMessageEnd();
    execute_first_step_result result = new execute_first_step_result();
    try {
      result.success = await iface_.execute_first_step(args.pending_query);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing execute_first_step");
      oprot.writeMessageBegin(new TMessage("execute_first_step", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("execute_first_step", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  broadcast_serialized_rows(int seqid, TProtocol iprot, TProtocol oprot) {
    broadcast_serialized_rows_args args = new broadcast_serialized_rows_args();
    args.read(iprot);
    iprot.readMessageEnd();
    broadcast_serialized_rows_result result = new broadcast_serialized_rows_result();
    try {
      iface_.broadcast_serialized_rows(args.serialized_rows, args.row_desc, args.query_id);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing broadcast_serialized_rows");
      oprot.writeMessageBegin(new TMessage("broadcast_serialized_rows", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("broadcast_serialized_rows", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  render_vega_raw_pixels(int seqid, TProtocol iprot, TProtocol oprot) async {
    render_vega_raw_pixels_args args = new render_vega_raw_pixels_args();
    args.read(iprot);
    iprot.readMessageEnd();
    render_vega_raw_pixels_result result = new render_vega_raw_pixels_result();
    try {
      result.success = await iface_.render_vega_raw_pixels(args.session, args.widget_id, args.node_idx, args.vega_json);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing render_vega_raw_pixels");
      oprot.writeMessageBegin(new TMessage("render_vega_raw_pixels", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("render_vega_raw_pixels", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  insert_data(int seqid, TProtocol iprot, TProtocol oprot) {
    insert_data_args args = new insert_data_args();
    args.read(iprot);
    iprot.readMessageEnd();
    insert_data_result result = new insert_data_result();
    try {
      iface_.insert_data(args.session, args.insert_data);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing insert_data");
      oprot.writeMessageBegin(new TMessage("insert_data", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("insert_data", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  get_table_descriptor(int seqid, TProtocol iprot, TProtocol oprot) async {
    get_table_descriptor_args args = new get_table_descriptor_args();
    args.read(iprot);
    iprot.readMessageEnd();
    get_table_descriptor_result result = new get_table_descriptor_result();
    try {
      result.success = await iface_.get_table_descriptor(args.session, args.table_name);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing get_table_descriptor");
      oprot.writeMessageBegin(new TMessage("get_table_descriptor", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("get_table_descriptor", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  get_row_descriptor(int seqid, TProtocol iprot, TProtocol oprot) async {
    get_row_descriptor_args args = new get_row_descriptor_args();
    args.read(iprot);
    iprot.readMessageEnd();
    get_row_descriptor_result result = new get_row_descriptor_result();
    try {
      result.success = await iface_.get_row_descriptor(args.session, args.table_name);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing get_row_descriptor");
      oprot.writeMessageBegin(new TMessage("get_row_descriptor", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("get_row_descriptor", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  render(int seqid, TProtocol iprot, TProtocol oprot) async {
    render_args args = new render_args();
    args.read(iprot);
    iprot.readMessageEnd();
    render_result result = new render_result();
    try {
      result.success = await iface_.render(args.session, args.query, args.render_type, args.nonce);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing render");
      oprot.writeMessageBegin(new TMessage("render", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("render", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  get_rows_for_pixels(int seqid, TProtocol iprot, TProtocol oprot) async {
    get_rows_for_pixels_args args = new get_rows_for_pixels_args();
    args.read(iprot);
    iprot.readMessageEnd();
    get_rows_for_pixels_result result = new get_rows_for_pixels_result();
    try {
      result.success = await iface_.get_rows_for_pixels(args.session, args.widget_id, args.pixels, args.table_name, args.col_names, args.column_format, args.nonce);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing get_rows_for_pixels");
      oprot.writeMessageBegin(new TMessage("get_rows_for_pixels", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("get_rows_for_pixels", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

  get_row_for_pixel(int seqid, TProtocol iprot, TProtocol oprot) async {
    get_row_for_pixel_args args = new get_row_for_pixel_args();
    args.read(iprot);
    iprot.readMessageEnd();
    get_row_for_pixel_result result = new get_row_for_pixel_result();
    try {
      result.success = await iface_.get_row_for_pixel(args.session, args.widget_id, args.pixel, args.table_name, args.col_names, args.column_format, args.pixelRadius, args.nonce);
    } on TMapDException catch(e) {
      result.e = e;
    } catch (th) {
      // Internal error
      TApplicationError x = new TApplicationError(TApplicationErrorType.INTERNAL_ERROR, "Internal error processing get_row_for_pixel");
      oprot.writeMessageBegin(new TMessage("get_row_for_pixel", TMessageType.EXCEPTION, seqid));
      x.write(oprot);
      oprot.writeMessageEnd();
      oprot.transport.flush();
      return;
    }
    oprot.writeMessageBegin(new TMessage("get_row_for_pixel", TMessageType.REPLY, seqid));
    result.write(oprot);
    oprot.writeMessageEnd();
    oprot.transport.flush();
  }

}

class connect_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("connect_args");
  static final TField _USER_FIELD_DESC = new TField("user", TType.STRING, 1);
  static final TField _PASSWD_FIELD_DESC = new TField("passwd", TType.STRING, 2);
  static final TField _DBNAME_FIELD_DESC = new TField("dbname", TType.STRING, 3);

  String _user;
  static const int USER = 1;
  String _passwd;
  static const int PASSWD = 2;
  String _dbname;
  static const int DBNAME = 3;


  connect_args() {
  }

  // user
  String get user => this._user;

  set user(String user) {
    this._user = user;
  }

  bool isSetUser() => this.user != null;

  unsetUser() {
    this.user = null;
  }

  // passwd
  String get passwd => this._passwd;

  set passwd(String passwd) {
    this._passwd = passwd;
  }

  bool isSetPasswd() => this.passwd != null;

  unsetPasswd() {
    this.passwd = null;
  }

  // dbname
  String get dbname => this._dbname;

  set dbname(String dbname) {
    this._dbname = dbname;
  }

  bool isSetDbname() => this.dbname != null;

  unsetDbname() {
    this.dbname = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case USER:
        return this.user;
      case PASSWD:
        return this.passwd;
      case DBNAME:
        return this.dbname;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case USER:
        if (value == null) {
          unsetUser();
        } else {
          this.user = value;
        }
        break;

      case PASSWD:
        if (value == null) {
          unsetPasswd();
        } else {
          this.passwd = value;
        }
        break;

      case DBNAME:
        if (value == null) {
          unsetDbname();
        } else {
          this.dbname = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case USER:
        return isSetUser();
      case PASSWD:
        return isSetPasswd();
      case DBNAME:
        return isSetDbname();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case USER:
          if (field.type == TType.STRING) {
            this.user = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PASSWD:
          if (field.type == TType.STRING) {
            this.passwd = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case DBNAME:
          if (field.type == TType.STRING) {
            this.dbname = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.user != null) {
      oprot.writeFieldBegin(_USER_FIELD_DESC);
      oprot.writeString(this.user);
      oprot.writeFieldEnd();
    }
    if (this.passwd != null) {
      oprot.writeFieldBegin(_PASSWD_FIELD_DESC);
      oprot.writeString(this.passwd);
      oprot.writeFieldEnd();
    }
    if (this.dbname != null) {
      oprot.writeFieldBegin(_DBNAME_FIELD_DESC);
      oprot.writeString(this.dbname);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("connect_args(");

    ret.write("user:");
    if (this.user == null) {
      ret.write("null");
    } else {
      ret.write(this.user);
    }

    ret.write(", ");
    ret.write("passwd:");
    if (this.passwd == null) {
      ret.write("null");
    } else {
      ret.write(this.passwd);
    }

    ret.write(", ");
    ret.write("dbname:");
    if (this.dbname == null) {
      ret.write("null");
    } else {
      ret.write(this.dbname);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class connect_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("connect_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRING, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  String _success;
  static const int SUCCESS = 0;
  TMapDException _e;
  static const int E = 1;


  connect_result() {
  }

  // success
  String get success => this._success;

  set success(String success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("connect_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class disconnect_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("disconnect_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);

  String _session;
  static const int SESSION = 1;


  disconnect_args() {
  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("disconnect_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class disconnect_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("disconnect_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TMapDException _e;
  static const int E = 1;


  disconnect_result() {
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("disconnect_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class get_server_status_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("get_server_status_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);

  String _session;
  static const int SESSION = 1;


  get_server_status_args() {
  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("get_server_status_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class get_server_status_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("get_server_status_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TServerStatus _success;
  static const int SUCCESS = 0;
  TMapDException _e;
  static const int E = 1;


  get_server_status_result() {
  }

  // success
  TServerStatus get success => this._success;

  set success(TServerStatus success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new TServerStatus();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("get_server_status_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class get_tables_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("get_tables_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);

  String _session;
  static const int SESSION = 1;


  get_tables_args() {
  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("get_tables_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class get_tables_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("get_tables_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<String> _success;
  static const int SUCCESS = 0;
  TMapDException _e;
  static const int E = 1;


  get_tables_result() {
  }

  // success
  List<String> get success => this._success;

  set success(List<String> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list90 = iprot.readListBegin();
              this.success = new List<String>();
              for (int _i91 = 0; _i91 < _list90.length; ++_i91) {
                String _elem92;
                _elem92 = iprot.readString();
                this.success.add(_elem92);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.success.length));
        for (var elem93 in this.success) {
          oprot.writeString(elem93);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("get_tables_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class get_table_details_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("get_table_details_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);
  static final TField _TABLE_NAME_FIELD_DESC = new TField("table_name", TType.STRING, 2);

  String _session;
  static const int SESSION = 1;
  String _table_name;
  static const int TABLE_NAME = 2;


  get_table_details_args() {
  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  // table_name
  String get table_name => this._table_name;

  set table_name(String table_name) {
    this._table_name = table_name;
  }

  bool isSetTable_name() => this.table_name != null;

  unsetTable_name() {
    this.table_name = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      case TABLE_NAME:
        return this.table_name;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      case TABLE_NAME:
        if (value == null) {
          unsetTable_name();
        } else {
          this.table_name = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      case TABLE_NAME:
        return isSetTable_name();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case TABLE_NAME:
          if (field.type == TType.STRING) {
            this.table_name = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    if (this.table_name != null) {
      oprot.writeFieldBegin(_TABLE_NAME_FIELD_DESC);
      oprot.writeString(this.table_name);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("get_table_details_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(", ");
    ret.write("table_name:");
    if (this.table_name == null) {
      ret.write("null");
    } else {
      ret.write(this.table_name);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class get_table_details_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("get_table_details_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TTableDetails _success;
  static const int SUCCESS = 0;
  TMapDException _e;
  static const int E = 1;


  get_table_details_result() {
  }

  // success
  TTableDetails get success => this._success;

  set success(TTableDetails success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new TTableDetails();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("get_table_details_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class get_internal_table_details_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("get_internal_table_details_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);
  static final TField _TABLE_NAME_FIELD_DESC = new TField("table_name", TType.STRING, 2);

  String _session;
  static const int SESSION = 1;
  String _table_name;
  static const int TABLE_NAME = 2;


  get_internal_table_details_args() {
  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  // table_name
  String get table_name => this._table_name;

  set table_name(String table_name) {
    this._table_name = table_name;
  }

  bool isSetTable_name() => this.table_name != null;

  unsetTable_name() {
    this.table_name = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      case TABLE_NAME:
        return this.table_name;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      case TABLE_NAME:
        if (value == null) {
          unsetTable_name();
        } else {
          this.table_name = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      case TABLE_NAME:
        return isSetTable_name();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case TABLE_NAME:
          if (field.type == TType.STRING) {
            this.table_name = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    if (this.table_name != null) {
      oprot.writeFieldBegin(_TABLE_NAME_FIELD_DESC);
      oprot.writeString(this.table_name);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("get_internal_table_details_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(", ");
    ret.write("table_name:");
    if (this.table_name == null) {
      ret.write("null");
    } else {
      ret.write(this.table_name);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class get_internal_table_details_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("get_internal_table_details_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TTableDetails _success;
  static const int SUCCESS = 0;
  TMapDException _e;
  static const int E = 1;


  get_internal_table_details_result() {
  }

  // success
  TTableDetails get success => this._success;

  set success(TTableDetails success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new TTableDetails();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("get_internal_table_details_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class get_users_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("get_users_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);

  String _session;
  static const int SESSION = 1;


  get_users_args() {
  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("get_users_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class get_users_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("get_users_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<String> _success;
  static const int SUCCESS = 0;
  TMapDException _e;
  static const int E = 1;


  get_users_result() {
  }

  // success
  List<String> get success => this._success;

  set success(List<String> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list94 = iprot.readListBegin();
              this.success = new List<String>();
              for (int _i95 = 0; _i95 < _list94.length; ++_i95) {
                String _elem96;
                _elem96 = iprot.readString();
                this.success.add(_elem96);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.success.length));
        for (var elem97 in this.success) {
          oprot.writeString(elem97);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("get_users_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class get_databases_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("get_databases_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);

  String _session;
  static const int SESSION = 1;


  get_databases_args() {
  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("get_databases_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class get_databases_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("get_databases_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<TDBInfo> _success;
  static const int SUCCESS = 0;
  TMapDException _e;
  static const int E = 1;


  get_databases_result() {
  }

  // success
  List<TDBInfo> get success => this._success;

  set success(List<TDBInfo> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list98 = iprot.readListBegin();
              this.success = new List<TDBInfo>();
              for (int _i99 = 0; _i99 < _list98.length; ++_i99) {
                TDBInfo _elem100;
                _elem100 = new TDBInfo();
                _elem100.read(iprot);
                this.success.add(_elem100);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem101 in this.success) {
          elem101.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("get_databases_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class get_version_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("get_version_args");



  get_version_args() {
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("get_version_args(");

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class get_version_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("get_version_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRING, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  String _success;
  static const int SUCCESS = 0;
  TMapDException _e;
  static const int E = 1;


  get_version_result() {
  }

  // success
  String get success => this._success;

  set success(String success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("get_version_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class start_heap_profile_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("start_heap_profile_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);

  String _session;
  static const int SESSION = 1;


  start_heap_profile_args() {
  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("start_heap_profile_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class start_heap_profile_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("start_heap_profile_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TMapDException _e;
  static const int E = 1;


  start_heap_profile_result() {
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("start_heap_profile_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class stop_heap_profile_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("stop_heap_profile_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);

  String _session;
  static const int SESSION = 1;


  stop_heap_profile_args() {
  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("stop_heap_profile_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class stop_heap_profile_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("stop_heap_profile_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TMapDException _e;
  static const int E = 1;


  stop_heap_profile_result() {
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("stop_heap_profile_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class get_heap_profile_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("get_heap_profile_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);

  String _session;
  static const int SESSION = 1;


  get_heap_profile_args() {
  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("get_heap_profile_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class get_heap_profile_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("get_heap_profile_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRING, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  String _success;
  static const int SUCCESS = 0;
  TMapDException _e;
  static const int E = 1;


  get_heap_profile_result() {
  }

  // success
  String get success => this._success;

  set success(String success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("get_heap_profile_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class get_memory_gpu_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("get_memory_gpu_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);

  String _session;
  static const int SESSION = 1;


  get_memory_gpu_args() {
  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("get_memory_gpu_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class get_memory_gpu_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("get_memory_gpu_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRING, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  String _success;
  static const int SUCCESS = 0;
  TMapDException _e;
  static const int E = 1;


  get_memory_gpu_result() {
  }

  // success
  String get success => this._success;

  set success(String success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("get_memory_gpu_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class get_memory_cpu_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("get_memory_cpu_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);

  String _session;
  static const int SESSION = 1;


  get_memory_cpu_args() {
  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("get_memory_cpu_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class get_memory_cpu_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("get_memory_cpu_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRING, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  String _success;
  static const int SUCCESS = 0;
  TMapDException _e;
  static const int E = 1;


  get_memory_cpu_result() {
  }

  // success
  String get success => this._success;

  set success(String success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("get_memory_cpu_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class get_memory_summary_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("get_memory_summary_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);

  String _session;
  static const int SESSION = 1;


  get_memory_summary_args() {
  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("get_memory_summary_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class get_memory_summary_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("get_memory_summary_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TMemorySummary _success;
  static const int SUCCESS = 0;
  TMapDException _e;
  static const int E = 1;


  get_memory_summary_result() {
  }

  // success
  TMemorySummary get success => this._success;

  set success(TMemorySummary success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new TMemorySummary();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("get_memory_summary_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class clear_cpu_memory_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("clear_cpu_memory_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);

  String _session;
  static const int SESSION = 1;


  clear_cpu_memory_args() {
  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("clear_cpu_memory_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class clear_cpu_memory_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("clear_cpu_memory_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TMapDException _e;
  static const int E = 1;


  clear_cpu_memory_result() {
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("clear_cpu_memory_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class clear_gpu_memory_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("clear_gpu_memory_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);

  String _session;
  static const int SESSION = 1;


  clear_gpu_memory_args() {
  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("clear_gpu_memory_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class clear_gpu_memory_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("clear_gpu_memory_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TMapDException _e;
  static const int E = 1;


  clear_gpu_memory_result() {
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("clear_gpu_memory_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class rollback_table_epoch_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("rollback_table_epoch_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);
  static final TField _DB_ID_FIELD_DESC = new TField("db_id", TType.I32, 2);
  static final TField _TABLE_ID_FIELD_DESC = new TField("table_id", TType.I32, 3);
  static final TField _NEW_EPOCH_FIELD_DESC = new TField("new_epoch", TType.I32, 4);

  String _session;
  static const int SESSION = 1;
  int _db_id = 0;
  static const int DB_ID = 2;
  int _table_id = 0;
  static const int TABLE_ID = 3;
  int _new_epoch = 0;
  static const int NEW_EPOCH = 4;

  bool __isset_db_id = false;
  bool __isset_table_id = false;
  bool __isset_new_epoch = false;

  rollback_table_epoch_args() {
  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  // db_id
  int get db_id => this._db_id;

  set db_id(int db_id) {
    this._db_id = db_id;
    this.__isset_db_id = true;
  }

  bool isSetDb_id() => this.__isset_db_id;

  unsetDb_id() {
    this.__isset_db_id = false;
  }

  // table_id
  int get table_id => this._table_id;

  set table_id(int table_id) {
    this._table_id = table_id;
    this.__isset_table_id = true;
  }

  bool isSetTable_id() => this.__isset_table_id;

  unsetTable_id() {
    this.__isset_table_id = false;
  }

  // new_epoch
  int get new_epoch => this._new_epoch;

  set new_epoch(int new_epoch) {
    this._new_epoch = new_epoch;
    this.__isset_new_epoch = true;
  }

  bool isSetNew_epoch() => this.__isset_new_epoch;

  unsetNew_epoch() {
    this.__isset_new_epoch = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      case DB_ID:
        return this.db_id;
      case TABLE_ID:
        return this.table_id;
      case NEW_EPOCH:
        return this.new_epoch;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      case DB_ID:
        if (value == null) {
          unsetDb_id();
        } else {
          this.db_id = value;
        }
        break;

      case TABLE_ID:
        if (value == null) {
          unsetTable_id();
        } else {
          this.table_id = value;
        }
        break;

      case NEW_EPOCH:
        if (value == null) {
          unsetNew_epoch();
        } else {
          this.new_epoch = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      case DB_ID:
        return isSetDb_id();
      case TABLE_ID:
        return isSetTable_id();
      case NEW_EPOCH:
        return isSetNew_epoch();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case DB_ID:
          if (field.type == TType.I32) {
            this.db_id = iprot.readI32();
            this.__isset_db_id = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case TABLE_ID:
          if (field.type == TType.I32) {
            this.table_id = iprot.readI32();
            this.__isset_table_id = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NEW_EPOCH:
          if (field.type == TType.I32) {
            this.new_epoch = iprot.readI32();
            this.__isset_new_epoch = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_DB_ID_FIELD_DESC);
    oprot.writeI32(this.db_id);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_TABLE_ID_FIELD_DESC);
    oprot.writeI32(this.table_id);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_NEW_EPOCH_FIELD_DESC);
    oprot.writeI32(this.new_epoch);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("rollback_table_epoch_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(", ");
    ret.write("db_id:");
    ret.write(this.db_id);

    ret.write(", ");
    ret.write("table_id:");
    ret.write(this.table_id);

    ret.write(", ");
    ret.write("new_epoch:");
    ret.write(this.new_epoch);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class rollback_table_epoch_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("rollback_table_epoch_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TMapDException _e;
  static const int E = 1;


  rollback_table_epoch_result() {
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("rollback_table_epoch_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class sql_execute_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("sql_execute_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);
  static final TField _QUERY_FIELD_DESC = new TField("query", TType.STRING, 2);
  static final TField _COLUMN_FORMAT_FIELD_DESC = new TField("column_format", TType.BOOL, 3);
  static final TField _NONCE_FIELD_DESC = new TField("nonce", TType.STRING, 4);
  static final TField _FIRST_N_FIELD_DESC = new TField("first_n", TType.I32, 5);

  String _session;
  static const int SESSION = 1;
  String _query;
  static const int QUERY = 2;
  bool _column_format = false;
  static const int COLUMN_FORMAT = 3;
  String _nonce;
  static const int NONCE = 4;
  int _first_n = 0;
  static const int FIRST_N = 5;

  bool __isset_column_format = false;
  bool __isset_first_n = false;

  sql_execute_args() {
    this.first_n = -1;

  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  // query
  String get query => this._query;

  set query(String query) {
    this._query = query;
  }

  bool isSetQuery() => this.query != null;

  unsetQuery() {
    this.query = null;
  }

  // column_format
  bool get column_format => this._column_format;

  set column_format(bool column_format) {
    this._column_format = column_format;
    this.__isset_column_format = true;
  }

  bool isSetColumn_format() => this.__isset_column_format;

  unsetColumn_format() {
    this.__isset_column_format = false;
  }

  // nonce
  String get nonce => this._nonce;

  set nonce(String nonce) {
    this._nonce = nonce;
  }

  bool isSetNonce() => this.nonce != null;

  unsetNonce() {
    this.nonce = null;
  }

  // first_n
  int get first_n => this._first_n;

  set first_n(int first_n) {
    this._first_n = first_n;
    this.__isset_first_n = true;
  }

  bool isSetFirst_n() => this.__isset_first_n;

  unsetFirst_n() {
    this.__isset_first_n = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      case QUERY:
        return this.query;
      case COLUMN_FORMAT:
        return this.column_format;
      case NONCE:
        return this.nonce;
      case FIRST_N:
        return this.first_n;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      case QUERY:
        if (value == null) {
          unsetQuery();
        } else {
          this.query = value;
        }
        break;

      case COLUMN_FORMAT:
        if (value == null) {
          unsetColumn_format();
        } else {
          this.column_format = value;
        }
        break;

      case NONCE:
        if (value == null) {
          unsetNonce();
        } else {
          this.nonce = value;
        }
        break;

      case FIRST_N:
        if (value == null) {
          unsetFirst_n();
        } else {
          this.first_n = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      case QUERY:
        return isSetQuery();
      case COLUMN_FORMAT:
        return isSetColumn_format();
      case NONCE:
        return isSetNonce();
      case FIRST_N:
        return isSetFirst_n();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case QUERY:
          if (field.type == TType.STRING) {
            this.query = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case COLUMN_FORMAT:
          if (field.type == TType.BOOL) {
            this.column_format = iprot.readBool();
            this.__isset_column_format = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NONCE:
          if (field.type == TType.STRING) {
            this.nonce = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case FIRST_N:
          if (field.type == TType.I32) {
            this.first_n = iprot.readI32();
            this.__isset_first_n = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    if (this.query != null) {
      oprot.writeFieldBegin(_QUERY_FIELD_DESC);
      oprot.writeString(this.query);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_COLUMN_FORMAT_FIELD_DESC);
    oprot.writeBool(this.column_format);
    oprot.writeFieldEnd();
    if (this.nonce != null) {
      oprot.writeFieldBegin(_NONCE_FIELD_DESC);
      oprot.writeString(this.nonce);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_FIRST_N_FIELD_DESC);
    oprot.writeI32(this.first_n);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("sql_execute_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(", ");
    ret.write("query:");
    if (this.query == null) {
      ret.write("null");
    } else {
      ret.write(this.query);
    }

    ret.write(", ");
    ret.write("column_format:");
    ret.write(this.column_format);

    ret.write(", ");
    ret.write("nonce:");
    if (this.nonce == null) {
      ret.write("null");
    } else {
      ret.write(this.nonce);
    }

    ret.write(", ");
    ret.write("first_n:");
    ret.write(this.first_n);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class sql_execute_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("sql_execute_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TQueryResult _success;
  static const int SUCCESS = 0;
  TMapDException _e;
  static const int E = 1;


  sql_execute_result() {
  }

  // success
  TQueryResult get success => this._success;

  set success(TQueryResult success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new TQueryResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("sql_execute_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class sql_execute_df_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("sql_execute_df_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);
  static final TField _QUERY_FIELD_DESC = new TField("query", TType.STRING, 2);
  static final TField _DEVICE_TYPE_FIELD_DESC = new TField("device_type", TType.I32, 3);
  static final TField _DEVICE_ID_FIELD_DESC = new TField("device_id", TType.I32, 4);
  static final TField _FIRST_N_FIELD_DESC = new TField("first_n", TType.I32, 5);

  String _session;
  static const int SESSION = 1;
  String _query;
  static const int QUERY = 2;
  int _device_type;
  static const int DEVICE_TYPE = 3;
  int _device_id = 0;
  static const int DEVICE_ID = 4;
  int _first_n = 0;
  static const int FIRST_N = 5;

  bool __isset_device_type = false;
  bool __isset_device_id = false;
  bool __isset_first_n = false;

  sql_execute_df_args() {
    this.device_id = 0;

    this.first_n = -1;

  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  // query
  String get query => this._query;

  set query(String query) {
    this._query = query;
  }

  bool isSetQuery() => this.query != null;

  unsetQuery() {
    this.query = null;
  }

  // device_type
  int get device_type => this._device_type;

  set device_type(int device_type) {
    this._device_type = device_type;
    this.__isset_device_type = true;
  }

  bool isSetDevice_type() => this.__isset_device_type;

  unsetDevice_type() {
    this.__isset_device_type = false;
  }

  // device_id
  int get device_id => this._device_id;

  set device_id(int device_id) {
    this._device_id = device_id;
    this.__isset_device_id = true;
  }

  bool isSetDevice_id() => this.__isset_device_id;

  unsetDevice_id() {
    this.__isset_device_id = false;
  }

  // first_n
  int get first_n => this._first_n;

  set first_n(int first_n) {
    this._first_n = first_n;
    this.__isset_first_n = true;
  }

  bool isSetFirst_n() => this.__isset_first_n;

  unsetFirst_n() {
    this.__isset_first_n = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      case QUERY:
        return this.query;
      case DEVICE_TYPE:
        return this.device_type;
      case DEVICE_ID:
        return this.device_id;
      case FIRST_N:
        return this.first_n;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      case QUERY:
        if (value == null) {
          unsetQuery();
        } else {
          this.query = value;
        }
        break;

      case DEVICE_TYPE:
        if (value == null) {
          unsetDevice_type();
        } else {
          this.device_type = value;
        }
        break;

      case DEVICE_ID:
        if (value == null) {
          unsetDevice_id();
        } else {
          this.device_id = value;
        }
        break;

      case FIRST_N:
        if (value == null) {
          unsetFirst_n();
        } else {
          this.first_n = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      case QUERY:
        return isSetQuery();
      case DEVICE_TYPE:
        return isSetDevice_type();
      case DEVICE_ID:
        return isSetDevice_id();
      case FIRST_N:
        return isSetFirst_n();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case QUERY:
          if (field.type == TType.STRING) {
            this.query = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case DEVICE_TYPE:
          if (field.type == TType.I32) {
            this.device_type = iprot.readI32();
            this.__isset_device_type = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case DEVICE_ID:
          if (field.type == TType.I32) {
            this.device_id = iprot.readI32();
            this.__isset_device_id = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case FIRST_N:
          if (field.type == TType.I32) {
            this.first_n = iprot.readI32();
            this.__isset_first_n = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    if (this.query != null) {
      oprot.writeFieldBegin(_QUERY_FIELD_DESC);
      oprot.writeString(this.query);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_DEVICE_TYPE_FIELD_DESC);
    oprot.writeI32(this.device_type);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_DEVICE_ID_FIELD_DESC);
    oprot.writeI32(this.device_id);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_FIRST_N_FIELD_DESC);
    oprot.writeI32(this.first_n);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("sql_execute_df_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(", ");
    ret.write("query:");
    if (this.query == null) {
      ret.write("null");
    } else {
      ret.write(this.query);
    }

    ret.write(", ");
    ret.write("device_type:");
    String device_type_name = TDeviceType.VALUES_TO_NAMES[this.device_type];
    if (device_type_name != null) {
      ret.write(device_type_name);
      ret.write(" (");
    }
    ret.write(this.device_type);
    if (device_type_name != null) {
      ret.write(")");
    }

    ret.write(", ");
    ret.write("device_id:");
    ret.write(this.device_id);

    ret.write(", ");
    ret.write("first_n:");
    ret.write(this.first_n);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetDevice_type() && !TDeviceType.VALID_VALUES.contains(device_type)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'device_type' has been assigned the invalid value $device_type");
    }
  }

}

class sql_execute_df_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("sql_execute_df_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TDataFrame _success;
  static const int SUCCESS = 0;
  TMapDException _e;
  static const int E = 1;


  sql_execute_df_result() {
  }

  // success
  TDataFrame get success => this._success;

  set success(TDataFrame success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new TDataFrame();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("sql_execute_df_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class sql_execute_gdf_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("sql_execute_gdf_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);
  static final TField _QUERY_FIELD_DESC = new TField("query", TType.STRING, 2);
  static final TField _DEVICE_ID_FIELD_DESC = new TField("device_id", TType.I32, 3);
  static final TField _FIRST_N_FIELD_DESC = new TField("first_n", TType.I32, 4);

  String _session;
  static const int SESSION = 1;
  String _query;
  static const int QUERY = 2;
  int _device_id = 0;
  static const int DEVICE_ID = 3;
  int _first_n = 0;
  static const int FIRST_N = 4;

  bool __isset_device_id = false;
  bool __isset_first_n = false;

  sql_execute_gdf_args() {
    this.device_id = 0;

    this.first_n = -1;

  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  // query
  String get query => this._query;

  set query(String query) {
    this._query = query;
  }

  bool isSetQuery() => this.query != null;

  unsetQuery() {
    this.query = null;
  }

  // device_id
  int get device_id => this._device_id;

  set device_id(int device_id) {
    this._device_id = device_id;
    this.__isset_device_id = true;
  }

  bool isSetDevice_id() => this.__isset_device_id;

  unsetDevice_id() {
    this.__isset_device_id = false;
  }

  // first_n
  int get first_n => this._first_n;

  set first_n(int first_n) {
    this._first_n = first_n;
    this.__isset_first_n = true;
  }

  bool isSetFirst_n() => this.__isset_first_n;

  unsetFirst_n() {
    this.__isset_first_n = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      case QUERY:
        return this.query;
      case DEVICE_ID:
        return this.device_id;
      case FIRST_N:
        return this.first_n;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      case QUERY:
        if (value == null) {
          unsetQuery();
        } else {
          this.query = value;
        }
        break;

      case DEVICE_ID:
        if (value == null) {
          unsetDevice_id();
        } else {
          this.device_id = value;
        }
        break;

      case FIRST_N:
        if (value == null) {
          unsetFirst_n();
        } else {
          this.first_n = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      case QUERY:
        return isSetQuery();
      case DEVICE_ID:
        return isSetDevice_id();
      case FIRST_N:
        return isSetFirst_n();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case QUERY:
          if (field.type == TType.STRING) {
            this.query = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case DEVICE_ID:
          if (field.type == TType.I32) {
            this.device_id = iprot.readI32();
            this.__isset_device_id = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case FIRST_N:
          if (field.type == TType.I32) {
            this.first_n = iprot.readI32();
            this.__isset_first_n = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    if (this.query != null) {
      oprot.writeFieldBegin(_QUERY_FIELD_DESC);
      oprot.writeString(this.query);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_DEVICE_ID_FIELD_DESC);
    oprot.writeI32(this.device_id);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_FIRST_N_FIELD_DESC);
    oprot.writeI32(this.first_n);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("sql_execute_gdf_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(", ");
    ret.write("query:");
    if (this.query == null) {
      ret.write("null");
    } else {
      ret.write(this.query);
    }

    ret.write(", ");
    ret.write("device_id:");
    ret.write(this.device_id);

    ret.write(", ");
    ret.write("first_n:");
    ret.write(this.first_n);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class sql_execute_gdf_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("sql_execute_gdf_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TDataFrame _success;
  static const int SUCCESS = 0;
  TMapDException _e;
  static const int E = 1;


  sql_execute_gdf_result() {
  }

  // success
  TDataFrame get success => this._success;

  set success(TDataFrame success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new TDataFrame();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("sql_execute_gdf_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class interrupt_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("interrupt_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);

  String _session;
  static const int SESSION = 1;


  interrupt_args() {
  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("interrupt_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class interrupt_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("interrupt_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TMapDException _e;
  static const int E = 1;


  interrupt_result() {
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("interrupt_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class sql_validate_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("sql_validate_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);
  static final TField _QUERY_FIELD_DESC = new TField("query", TType.STRING, 2);

  String _session;
  static const int SESSION = 1;
  String _query;
  static const int QUERY = 2;


  sql_validate_args() {
  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  // query
  String get query => this._query;

  set query(String query) {
    this._query = query;
  }

  bool isSetQuery() => this.query != null;

  unsetQuery() {
    this.query = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      case QUERY:
        return this.query;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      case QUERY:
        if (value == null) {
          unsetQuery();
        } else {
          this.query = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      case QUERY:
        return isSetQuery();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case QUERY:
          if (field.type == TType.STRING) {
            this.query = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    if (this.query != null) {
      oprot.writeFieldBegin(_QUERY_FIELD_DESC);
      oprot.writeString(this.query);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("sql_validate_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(", ");
    ret.write("query:");
    if (this.query == null) {
      ret.write("null");
    } else {
      ret.write(this.query);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class sql_validate_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("sql_validate_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.MAP, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Map<String, TColumnType> _success;
  static const int SUCCESS = 0;
  TMapDException _e;
  static const int E = 1;


  sql_validate_result() {
  }

  // success
  Map<String, TColumnType> get success => this._success;

  set success(Map<String, TColumnType> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.MAP) {
            {
              TMap _map102 = iprot.readMapBegin();
              this.success = new Map<String, TColumnType>();
              for (int _i103 = 0; _i103 < _map102.length; ++_i103) {
                String _key104;
                TColumnType _val105;
                _key104 = iprot.readString();
                _val105 = new TColumnType();
                _val105.read(iprot);
                this.success[_key104] = _val105;
              }
              iprot.readMapEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeMapBegin(new TMap(TType.STRING, TType.STRUCT, this.success.length));
        for (var elem107 in this.success.keys) {
          oprot.writeString(elem107);
          this.success[elem107].write(oprot);
        }
        oprot.writeMapEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("sql_validate_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class set_execution_mode_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("set_execution_mode_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);
  static final TField _MODE_FIELD_DESC = new TField("mode", TType.I32, 2);

  String _session;
  static const int SESSION = 1;
  int _mode;
  static const int MODE = 2;

  bool __isset_mode = false;

  set_execution_mode_args() {
  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  // mode
  int get mode => this._mode;

  set mode(int mode) {
    this._mode = mode;
    this.__isset_mode = true;
  }

  bool isSetMode() => this.__isset_mode;

  unsetMode() {
    this.__isset_mode = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      case MODE:
        return this.mode;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      case MODE:
        if (value == null) {
          unsetMode();
        } else {
          this.mode = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      case MODE:
        return isSetMode();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MODE:
          if (field.type == TType.I32) {
            this.mode = iprot.readI32();
            this.__isset_mode = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_MODE_FIELD_DESC);
    oprot.writeI32(this.mode);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("set_execution_mode_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(", ");
    ret.write("mode:");
    String mode_name = TExecuteMode.VALUES_TO_NAMES[this.mode];
    if (mode_name != null) {
      ret.write(mode_name);
      ret.write(" (");
    }
    ret.write(this.mode);
    if (mode_name != null) {
      ret.write(")");
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetMode() && !TExecuteMode.VALID_VALUES.contains(mode)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'mode' has been assigned the invalid value $mode");
    }
  }

}

class set_execution_mode_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("set_execution_mode_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TMapDException _e;
  static const int E = 1;


  set_execution_mode_result() {
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("set_execution_mode_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class render_vega_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("render_vega_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);
  static final TField _WIDGET_ID_FIELD_DESC = new TField("widget_id", TType.I64, 2);
  static final TField _VEGA_JSON_FIELD_DESC = new TField("vega_json", TType.STRING, 3);
  static final TField _COMPRESSION_LEVEL_FIELD_DESC = new TField("compression_level", TType.I32, 4);
  static final TField _NONCE_FIELD_DESC = new TField("nonce", TType.STRING, 5);

  String _session;
  static const int SESSION = 1;
  int _widget_id = 0;
  static const int WIDGET_ID = 2;
  String _vega_json;
  static const int VEGA_JSON = 3;
  int _compression_level = 0;
  static const int COMPRESSION_LEVEL = 4;
  String _nonce;
  static const int NONCE = 5;

  bool __isset_widget_id = false;
  bool __isset_compression_level = false;

  render_vega_args() {
  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  // widget_id
  int get widget_id => this._widget_id;

  set widget_id(int widget_id) {
    this._widget_id = widget_id;
    this.__isset_widget_id = true;
  }

  bool isSetWidget_id() => this.__isset_widget_id;

  unsetWidget_id() {
    this.__isset_widget_id = false;
  }

  // vega_json
  String get vega_json => this._vega_json;

  set vega_json(String vega_json) {
    this._vega_json = vega_json;
  }

  bool isSetVega_json() => this.vega_json != null;

  unsetVega_json() {
    this.vega_json = null;
  }

  // compression_level
  int get compression_level => this._compression_level;

  set compression_level(int compression_level) {
    this._compression_level = compression_level;
    this.__isset_compression_level = true;
  }

  bool isSetCompression_level() => this.__isset_compression_level;

  unsetCompression_level() {
    this.__isset_compression_level = false;
  }

  // nonce
  String get nonce => this._nonce;

  set nonce(String nonce) {
    this._nonce = nonce;
  }

  bool isSetNonce() => this.nonce != null;

  unsetNonce() {
    this.nonce = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      case WIDGET_ID:
        return this.widget_id;
      case VEGA_JSON:
        return this.vega_json;
      case COMPRESSION_LEVEL:
        return this.compression_level;
      case NONCE:
        return this.nonce;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      case WIDGET_ID:
        if (value == null) {
          unsetWidget_id();
        } else {
          this.widget_id = value;
        }
        break;

      case VEGA_JSON:
        if (value == null) {
          unsetVega_json();
        } else {
          this.vega_json = value;
        }
        break;

      case COMPRESSION_LEVEL:
        if (value == null) {
          unsetCompression_level();
        } else {
          this.compression_level = value;
        }
        break;

      case NONCE:
        if (value == null) {
          unsetNonce();
        } else {
          this.nonce = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      case WIDGET_ID:
        return isSetWidget_id();
      case VEGA_JSON:
        return isSetVega_json();
      case COMPRESSION_LEVEL:
        return isSetCompression_level();
      case NONCE:
        return isSetNonce();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case WIDGET_ID:
          if (field.type == TType.I64) {
            this.widget_id = iprot.readI64();
            this.__isset_widget_id = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case VEGA_JSON:
          if (field.type == TType.STRING) {
            this.vega_json = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case COMPRESSION_LEVEL:
          if (field.type == TType.I32) {
            this.compression_level = iprot.readI32();
            this.__isset_compression_level = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NONCE:
          if (field.type == TType.STRING) {
            this.nonce = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_WIDGET_ID_FIELD_DESC);
    oprot.writeI64(this.widget_id);
    oprot.writeFieldEnd();
    if (this.vega_json != null) {
      oprot.writeFieldBegin(_VEGA_JSON_FIELD_DESC);
      oprot.writeString(this.vega_json);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_COMPRESSION_LEVEL_FIELD_DESC);
    oprot.writeI32(this.compression_level);
    oprot.writeFieldEnd();
    if (this.nonce != null) {
      oprot.writeFieldBegin(_NONCE_FIELD_DESC);
      oprot.writeString(this.nonce);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("render_vega_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(", ");
    ret.write("widget_id:");
    ret.write(this.widget_id);

    ret.write(", ");
    ret.write("vega_json:");
    if (this.vega_json == null) {
      ret.write("null");
    } else {
      ret.write(this.vega_json);
    }

    ret.write(", ");
    ret.write("compression_level:");
    ret.write(this.compression_level);

    ret.write(", ");
    ret.write("nonce:");
    if (this.nonce == null) {
      ret.write("null");
    } else {
      ret.write(this.nonce);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class render_vega_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("render_vega_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TRenderResult _success;
  static const int SUCCESS = 0;
  TMapDException _e;
  static const int E = 1;


  render_vega_result() {
  }

  // success
  TRenderResult get success => this._success;

  set success(TRenderResult success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new TRenderResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("render_vega_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class get_result_row_for_pixel_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("get_result_row_for_pixel_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);
  static final TField _WIDGET_ID_FIELD_DESC = new TField("widget_id", TType.I64, 2);
  static final TField _PIXEL_FIELD_DESC = new TField("pixel", TType.STRUCT, 3);
  static final TField _TABLE_COL_NAMES_FIELD_DESC = new TField("table_col_names", TType.MAP, 4);
  static final TField _COLUMN_FORMAT_FIELD_DESC = new TField("column_format", TType.BOOL, 5);
  static final TField _PIXEL_RADIUS_FIELD_DESC = new TField("pixelRadius", TType.I32, 6);
  static final TField _NONCE_FIELD_DESC = new TField("nonce", TType.STRING, 7);

  String _session;
  static const int SESSION = 1;
  int _widget_id = 0;
  static const int WIDGET_ID = 2;
  TPixel _pixel;
  static const int PIXEL = 3;
  Map<String, List<String>> _table_col_names;
  static const int TABLE_COL_NAMES = 4;
  bool _column_format = false;
  static const int COLUMN_FORMAT = 5;
  int _pixelRadius = 0;
  static const int PIXELRADIUS = 6;
  String _nonce;
  static const int NONCE = 7;

  bool __isset_widget_id = false;
  bool __isset_column_format = false;
  bool __isset_pixelRadius = false;

  get_result_row_for_pixel_args() {
  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  // widget_id
  int get widget_id => this._widget_id;

  set widget_id(int widget_id) {
    this._widget_id = widget_id;
    this.__isset_widget_id = true;
  }

  bool isSetWidget_id() => this.__isset_widget_id;

  unsetWidget_id() {
    this.__isset_widget_id = false;
  }

  // pixel
  TPixel get pixel => this._pixel;

  set pixel(TPixel pixel) {
    this._pixel = pixel;
  }

  bool isSetPixel() => this.pixel != null;

  unsetPixel() {
    this.pixel = null;
  }

  // table_col_names
  Map<String, List<String>> get table_col_names => this._table_col_names;

  set table_col_names(Map<String, List<String>> table_col_names) {
    this._table_col_names = table_col_names;
  }

  bool isSetTable_col_names() => this.table_col_names != null;

  unsetTable_col_names() {
    this.table_col_names = null;
  }

  // column_format
  bool get column_format => this._column_format;

  set column_format(bool column_format) {
    this._column_format = column_format;
    this.__isset_column_format = true;
  }

  bool isSetColumn_format() => this.__isset_column_format;

  unsetColumn_format() {
    this.__isset_column_format = false;
  }

  // pixelRadius
  int get pixelRadius => this._pixelRadius;

  set pixelRadius(int pixelRadius) {
    this._pixelRadius = pixelRadius;
    this.__isset_pixelRadius = true;
  }

  bool isSetPixelRadius() => this.__isset_pixelRadius;

  unsetPixelRadius() {
    this.__isset_pixelRadius = false;
  }

  // nonce
  String get nonce => this._nonce;

  set nonce(String nonce) {
    this._nonce = nonce;
  }

  bool isSetNonce() => this.nonce != null;

  unsetNonce() {
    this.nonce = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      case WIDGET_ID:
        return this.widget_id;
      case PIXEL:
        return this.pixel;
      case TABLE_COL_NAMES:
        return this.table_col_names;
      case COLUMN_FORMAT:
        return this.column_format;
      case PIXELRADIUS:
        return this.pixelRadius;
      case NONCE:
        return this.nonce;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      case WIDGET_ID:
        if (value == null) {
          unsetWidget_id();
        } else {
          this.widget_id = value;
        }
        break;

      case PIXEL:
        if (value == null) {
          unsetPixel();
        } else {
          this.pixel = value;
        }
        break;

      case TABLE_COL_NAMES:
        if (value == null) {
          unsetTable_col_names();
        } else {
          this.table_col_names = value;
        }
        break;

      case COLUMN_FORMAT:
        if (value == null) {
          unsetColumn_format();
        } else {
          this.column_format = value;
        }
        break;

      case PIXELRADIUS:
        if (value == null) {
          unsetPixelRadius();
        } else {
          this.pixelRadius = value;
        }
        break;

      case NONCE:
        if (value == null) {
          unsetNonce();
        } else {
          this.nonce = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      case WIDGET_ID:
        return isSetWidget_id();
      case PIXEL:
        return isSetPixel();
      case TABLE_COL_NAMES:
        return isSetTable_col_names();
      case COLUMN_FORMAT:
        return isSetColumn_format();
      case PIXELRADIUS:
        return isSetPixelRadius();
      case NONCE:
        return isSetNonce();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case WIDGET_ID:
          if (field.type == TType.I64) {
            this.widget_id = iprot.readI64();
            this.__isset_widget_id = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PIXEL:
          if (field.type == TType.STRUCT) {
            this.pixel = new TPixel();
            this.pixel.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case TABLE_COL_NAMES:
          if (field.type == TType.MAP) {
            {
              TMap _map108 = iprot.readMapBegin();
              this.table_col_names = new Map<String, List<String>>();
              for (int _i109 = 0; _i109 < _map108.length; ++_i109) {
                String _key110;
                List<String> _val111;
                _key110 = iprot.readString();
                {
                  TList _list112 = iprot.readListBegin();
                  _val111 = new List<String>();
                  for (int _i113 = 0; _i113 < _list112.length; ++_i113) {
                    String _elem114;
                    _elem114 = iprot.readString();
                    _val111.add(_elem114);
                  }
                  iprot.readListEnd();
                }
                this.table_col_names[_key110] = _val111;
              }
              iprot.readMapEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case COLUMN_FORMAT:
          if (field.type == TType.BOOL) {
            this.column_format = iprot.readBool();
            this.__isset_column_format = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PIXELRADIUS:
          if (field.type == TType.I32) {
            this.pixelRadius = iprot.readI32();
            this.__isset_pixelRadius = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NONCE:
          if (field.type == TType.STRING) {
            this.nonce = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_WIDGET_ID_FIELD_DESC);
    oprot.writeI64(this.widget_id);
    oprot.writeFieldEnd();
    if (this.pixel != null) {
      oprot.writeFieldBegin(_PIXEL_FIELD_DESC);
      this.pixel.write(oprot);
      oprot.writeFieldEnd();
    }
    if (this.table_col_names != null) {
      oprot.writeFieldBegin(_TABLE_COL_NAMES_FIELD_DESC);
      {
        oprot.writeMapBegin(new TMap(TType.STRING, TType.LIST, this.table_col_names.length));
        for (var elem116 in this.table_col_names.keys) {
          oprot.writeString(elem116);
          {
            oprot.writeListBegin(new TList(TType.STRING, this.table_col_names[elem116].length));
            for (var elem117 in this.table_col_names[elem116]) {
              oprot.writeString(elem117);
            }
            oprot.writeListEnd();
          }
        }
        oprot.writeMapEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_COLUMN_FORMAT_FIELD_DESC);
    oprot.writeBool(this.column_format);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_PIXEL_RADIUS_FIELD_DESC);
    oprot.writeI32(this.pixelRadius);
    oprot.writeFieldEnd();
    if (this.nonce != null) {
      oprot.writeFieldBegin(_NONCE_FIELD_DESC);
      oprot.writeString(this.nonce);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("get_result_row_for_pixel_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(", ");
    ret.write("widget_id:");
    ret.write(this.widget_id);

    ret.write(", ");
    ret.write("pixel:");
    if (this.pixel == null) {
      ret.write("null");
    } else {
      ret.write(this.pixel);
    }

    ret.write(", ");
    ret.write("table_col_names:");
    if (this.table_col_names == null) {
      ret.write("null");
    } else {
      ret.write(this.table_col_names);
    }

    ret.write(", ");
    ret.write("column_format:");
    ret.write(this.column_format);

    ret.write(", ");
    ret.write("pixelRadius:");
    ret.write(this.pixelRadius);

    ret.write(", ");
    ret.write("nonce:");
    if (this.nonce == null) {
      ret.write("null");
    } else {
      ret.write(this.nonce);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class get_result_row_for_pixel_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("get_result_row_for_pixel_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TPixelTableRowResult _success;
  static const int SUCCESS = 0;
  TMapDException _e;
  static const int E = 1;


  get_result_row_for_pixel_result() {
  }

  // success
  TPixelTableRowResult get success => this._success;

  set success(TPixelTableRowResult success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new TPixelTableRowResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("get_result_row_for_pixel_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class get_frontend_view_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("get_frontend_view_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);
  static final TField _VIEW_NAME_FIELD_DESC = new TField("view_name", TType.STRING, 2);

  String _session;
  static const int SESSION = 1;
  String _view_name;
  static const int VIEW_NAME = 2;


  get_frontend_view_args() {
  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  // view_name
  String get view_name => this._view_name;

  set view_name(String view_name) {
    this._view_name = view_name;
  }

  bool isSetView_name() => this.view_name != null;

  unsetView_name() {
    this.view_name = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      case VIEW_NAME:
        return this.view_name;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      case VIEW_NAME:
        if (value == null) {
          unsetView_name();
        } else {
          this.view_name = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      case VIEW_NAME:
        return isSetView_name();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case VIEW_NAME:
          if (field.type == TType.STRING) {
            this.view_name = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    if (this.view_name != null) {
      oprot.writeFieldBegin(_VIEW_NAME_FIELD_DESC);
      oprot.writeString(this.view_name);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("get_frontend_view_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(", ");
    ret.write("view_name:");
    if (this.view_name == null) {
      ret.write("null");
    } else {
      ret.write(this.view_name);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class get_frontend_view_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("get_frontend_view_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TFrontendView _success;
  static const int SUCCESS = 0;
  TMapDException _e;
  static const int E = 1;


  get_frontend_view_result() {
  }

  // success
  TFrontendView get success => this._success;

  set success(TFrontendView success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new TFrontendView();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("get_frontend_view_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class get_frontend_views_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("get_frontend_views_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);

  String _session;
  static const int SESSION = 1;


  get_frontend_views_args() {
  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("get_frontend_views_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class get_frontend_views_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("get_frontend_views_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<TFrontendView> _success;
  static const int SUCCESS = 0;
  TMapDException _e;
  static const int E = 1;


  get_frontend_views_result() {
  }

  // success
  List<TFrontendView> get success => this._success;

  set success(List<TFrontendView> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list118 = iprot.readListBegin();
              this.success = new List<TFrontendView>();
              for (int _i119 = 0; _i119 < _list118.length; ++_i119) {
                TFrontendView _elem120;
                _elem120 = new TFrontendView();
                _elem120.read(iprot);
                this.success.add(_elem120);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem121 in this.success) {
          elem121.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("get_frontend_views_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class create_frontend_view_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("create_frontend_view_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);
  static final TField _VIEW_NAME_FIELD_DESC = new TField("view_name", TType.STRING, 2);
  static final TField _VIEW_STATE_FIELD_DESC = new TField("view_state", TType.STRING, 3);
  static final TField _IMAGE_HASH_FIELD_DESC = new TField("image_hash", TType.STRING, 4);
  static final TField _VIEW_METADATA_FIELD_DESC = new TField("view_metadata", TType.STRING, 5);

  String _session;
  static const int SESSION = 1;
  String _view_name;
  static const int VIEW_NAME = 2;
  String _view_state;
  static const int VIEW_STATE = 3;
  String _image_hash;
  static const int IMAGE_HASH = 4;
  String _view_metadata;
  static const int VIEW_METADATA = 5;


  create_frontend_view_args() {
  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  // view_name
  String get view_name => this._view_name;

  set view_name(String view_name) {
    this._view_name = view_name;
  }

  bool isSetView_name() => this.view_name != null;

  unsetView_name() {
    this.view_name = null;
  }

  // view_state
  String get view_state => this._view_state;

  set view_state(String view_state) {
    this._view_state = view_state;
  }

  bool isSetView_state() => this.view_state != null;

  unsetView_state() {
    this.view_state = null;
  }

  // image_hash
  String get image_hash => this._image_hash;

  set image_hash(String image_hash) {
    this._image_hash = image_hash;
  }

  bool isSetImage_hash() => this.image_hash != null;

  unsetImage_hash() {
    this.image_hash = null;
  }

  // view_metadata
  String get view_metadata => this._view_metadata;

  set view_metadata(String view_metadata) {
    this._view_metadata = view_metadata;
  }

  bool isSetView_metadata() => this.view_metadata != null;

  unsetView_metadata() {
    this.view_metadata = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      case VIEW_NAME:
        return this.view_name;
      case VIEW_STATE:
        return this.view_state;
      case IMAGE_HASH:
        return this.image_hash;
      case VIEW_METADATA:
        return this.view_metadata;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      case VIEW_NAME:
        if (value == null) {
          unsetView_name();
        } else {
          this.view_name = value;
        }
        break;

      case VIEW_STATE:
        if (value == null) {
          unsetView_state();
        } else {
          this.view_state = value;
        }
        break;

      case IMAGE_HASH:
        if (value == null) {
          unsetImage_hash();
        } else {
          this.image_hash = value;
        }
        break;

      case VIEW_METADATA:
        if (value == null) {
          unsetView_metadata();
        } else {
          this.view_metadata = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      case VIEW_NAME:
        return isSetView_name();
      case VIEW_STATE:
        return isSetView_state();
      case IMAGE_HASH:
        return isSetImage_hash();
      case VIEW_METADATA:
        return isSetView_metadata();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case VIEW_NAME:
          if (field.type == TType.STRING) {
            this.view_name = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case VIEW_STATE:
          if (field.type == TType.STRING) {
            this.view_state = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case IMAGE_HASH:
          if (field.type == TType.STRING) {
            this.image_hash = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case VIEW_METADATA:
          if (field.type == TType.STRING) {
            this.view_metadata = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    if (this.view_name != null) {
      oprot.writeFieldBegin(_VIEW_NAME_FIELD_DESC);
      oprot.writeString(this.view_name);
      oprot.writeFieldEnd();
    }
    if (this.view_state != null) {
      oprot.writeFieldBegin(_VIEW_STATE_FIELD_DESC);
      oprot.writeString(this.view_state);
      oprot.writeFieldEnd();
    }
    if (this.image_hash != null) {
      oprot.writeFieldBegin(_IMAGE_HASH_FIELD_DESC);
      oprot.writeString(this.image_hash);
      oprot.writeFieldEnd();
    }
    if (this.view_metadata != null) {
      oprot.writeFieldBegin(_VIEW_METADATA_FIELD_DESC);
      oprot.writeString(this.view_metadata);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("create_frontend_view_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(", ");
    ret.write("view_name:");
    if (this.view_name == null) {
      ret.write("null");
    } else {
      ret.write(this.view_name);
    }

    ret.write(", ");
    ret.write("view_state:");
    if (this.view_state == null) {
      ret.write("null");
    } else {
      ret.write(this.view_state);
    }

    ret.write(", ");
    ret.write("image_hash:");
    if (this.image_hash == null) {
      ret.write("null");
    } else {
      ret.write(this.image_hash);
    }

    ret.write(", ");
    ret.write("view_metadata:");
    if (this.view_metadata == null) {
      ret.write("null");
    } else {
      ret.write(this.view_metadata);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class create_frontend_view_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("create_frontend_view_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TMapDException _e;
  static const int E = 1;


  create_frontend_view_result() {
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("create_frontend_view_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class delete_frontend_view_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("delete_frontend_view_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);
  static final TField _VIEW_NAME_FIELD_DESC = new TField("view_name", TType.STRING, 2);

  String _session;
  static const int SESSION = 1;
  String _view_name;
  static const int VIEW_NAME = 2;


  delete_frontend_view_args() {
  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  // view_name
  String get view_name => this._view_name;

  set view_name(String view_name) {
    this._view_name = view_name;
  }

  bool isSetView_name() => this.view_name != null;

  unsetView_name() {
    this.view_name = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      case VIEW_NAME:
        return this.view_name;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      case VIEW_NAME:
        if (value == null) {
          unsetView_name();
        } else {
          this.view_name = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      case VIEW_NAME:
        return isSetView_name();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case VIEW_NAME:
          if (field.type == TType.STRING) {
            this.view_name = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    if (this.view_name != null) {
      oprot.writeFieldBegin(_VIEW_NAME_FIELD_DESC);
      oprot.writeString(this.view_name);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("delete_frontend_view_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(", ");
    ret.write("view_name:");
    if (this.view_name == null) {
      ret.write("null");
    } else {
      ret.write(this.view_name);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class delete_frontend_view_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("delete_frontend_view_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TMapDException _e;
  static const int E = 1;


  delete_frontend_view_result() {
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("delete_frontend_view_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class get_link_view_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("get_link_view_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);
  static final TField _LINK_FIELD_DESC = new TField("link", TType.STRING, 2);

  String _session;
  static const int SESSION = 1;
  String _link;
  static const int LINK = 2;


  get_link_view_args() {
  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  // link
  String get link => this._link;

  set link(String link) {
    this._link = link;
  }

  bool isSetLink() => this.link != null;

  unsetLink() {
    this.link = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      case LINK:
        return this.link;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      case LINK:
        if (value == null) {
          unsetLink();
        } else {
          this.link = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      case LINK:
        return isSetLink();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LINK:
          if (field.type == TType.STRING) {
            this.link = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    if (this.link != null) {
      oprot.writeFieldBegin(_LINK_FIELD_DESC);
      oprot.writeString(this.link);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("get_link_view_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(", ");
    ret.write("link:");
    if (this.link == null) {
      ret.write("null");
    } else {
      ret.write(this.link);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class get_link_view_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("get_link_view_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TFrontendView _success;
  static const int SUCCESS = 0;
  TMapDException _e;
  static const int E = 1;


  get_link_view_result() {
  }

  // success
  TFrontendView get success => this._success;

  set success(TFrontendView success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new TFrontendView();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("get_link_view_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class create_link_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("create_link_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);
  static final TField _VIEW_STATE_FIELD_DESC = new TField("view_state", TType.STRING, 2);
  static final TField _VIEW_METADATA_FIELD_DESC = new TField("view_metadata", TType.STRING, 3);

  String _session;
  static const int SESSION = 1;
  String _view_state;
  static const int VIEW_STATE = 2;
  String _view_metadata;
  static const int VIEW_METADATA = 3;


  create_link_args() {
  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  // view_state
  String get view_state => this._view_state;

  set view_state(String view_state) {
    this._view_state = view_state;
  }

  bool isSetView_state() => this.view_state != null;

  unsetView_state() {
    this.view_state = null;
  }

  // view_metadata
  String get view_metadata => this._view_metadata;

  set view_metadata(String view_metadata) {
    this._view_metadata = view_metadata;
  }

  bool isSetView_metadata() => this.view_metadata != null;

  unsetView_metadata() {
    this.view_metadata = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      case VIEW_STATE:
        return this.view_state;
      case VIEW_METADATA:
        return this.view_metadata;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      case VIEW_STATE:
        if (value == null) {
          unsetView_state();
        } else {
          this.view_state = value;
        }
        break;

      case VIEW_METADATA:
        if (value == null) {
          unsetView_metadata();
        } else {
          this.view_metadata = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      case VIEW_STATE:
        return isSetView_state();
      case VIEW_METADATA:
        return isSetView_metadata();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case VIEW_STATE:
          if (field.type == TType.STRING) {
            this.view_state = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case VIEW_METADATA:
          if (field.type == TType.STRING) {
            this.view_metadata = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    if (this.view_state != null) {
      oprot.writeFieldBegin(_VIEW_STATE_FIELD_DESC);
      oprot.writeString(this.view_state);
      oprot.writeFieldEnd();
    }
    if (this.view_metadata != null) {
      oprot.writeFieldBegin(_VIEW_METADATA_FIELD_DESC);
      oprot.writeString(this.view_metadata);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("create_link_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(", ");
    ret.write("view_state:");
    if (this.view_state == null) {
      ret.write("null");
    } else {
      ret.write(this.view_state);
    }

    ret.write(", ");
    ret.write("view_metadata:");
    if (this.view_metadata == null) {
      ret.write("null");
    } else {
      ret.write(this.view_metadata);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class create_link_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("create_link_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRING, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  String _success;
  static const int SUCCESS = 0;
  TMapDException _e;
  static const int E = 1;


  create_link_result() {
  }

  // success
  String get success => this._success;

  set success(String success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("create_link_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class load_table_binary_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("load_table_binary_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);
  static final TField _TABLE_NAME_FIELD_DESC = new TField("table_name", TType.STRING, 2);
  static final TField _ROWS_FIELD_DESC = new TField("rows", TType.LIST, 3);

  String _session;
  static const int SESSION = 1;
  String _table_name;
  static const int TABLE_NAME = 2;
  List<TRow> _rows;
  static const int ROWS = 3;


  load_table_binary_args() {
  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  // table_name
  String get table_name => this._table_name;

  set table_name(String table_name) {
    this._table_name = table_name;
  }

  bool isSetTable_name() => this.table_name != null;

  unsetTable_name() {
    this.table_name = null;
  }

  // rows
  List<TRow> get rows => this._rows;

  set rows(List<TRow> rows) {
    this._rows = rows;
  }

  bool isSetRows() => this.rows != null;

  unsetRows() {
    this.rows = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      case TABLE_NAME:
        return this.table_name;
      case ROWS:
        return this.rows;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      case TABLE_NAME:
        if (value == null) {
          unsetTable_name();
        } else {
          this.table_name = value;
        }
        break;

      case ROWS:
        if (value == null) {
          unsetRows();
        } else {
          this.rows = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      case TABLE_NAME:
        return isSetTable_name();
      case ROWS:
        return isSetRows();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case TABLE_NAME:
          if (field.type == TType.STRING) {
            this.table_name = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ROWS:
          if (field.type == TType.LIST) {
            {
              TList _list122 = iprot.readListBegin();
              this.rows = new List<TRow>();
              for (int _i123 = 0; _i123 < _list122.length; ++_i123) {
                TRow _elem124;
                _elem124 = new TRow();
                _elem124.read(iprot);
                this.rows.add(_elem124);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    if (this.table_name != null) {
      oprot.writeFieldBegin(_TABLE_NAME_FIELD_DESC);
      oprot.writeString(this.table_name);
      oprot.writeFieldEnd();
    }
    if (this.rows != null) {
      oprot.writeFieldBegin(_ROWS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.rows.length));
        for (var elem125 in this.rows) {
          elem125.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("load_table_binary_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(", ");
    ret.write("table_name:");
    if (this.table_name == null) {
      ret.write("null");
    } else {
      ret.write(this.table_name);
    }

    ret.write(", ");
    ret.write("rows:");
    if (this.rows == null) {
      ret.write("null");
    } else {
      ret.write(this.rows);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class load_table_binary_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("load_table_binary_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TMapDException _e;
  static const int E = 1;


  load_table_binary_result() {
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("load_table_binary_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class load_table_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("load_table_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);
  static final TField _TABLE_NAME_FIELD_DESC = new TField("table_name", TType.STRING, 2);
  static final TField _ROWS_FIELD_DESC = new TField("rows", TType.LIST, 3);

  String _session;
  static const int SESSION = 1;
  String _table_name;
  static const int TABLE_NAME = 2;
  List<TStringRow> _rows;
  static const int ROWS = 3;


  load_table_args() {
  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  // table_name
  String get table_name => this._table_name;

  set table_name(String table_name) {
    this._table_name = table_name;
  }

  bool isSetTable_name() => this.table_name != null;

  unsetTable_name() {
    this.table_name = null;
  }

  // rows
  List<TStringRow> get rows => this._rows;

  set rows(List<TStringRow> rows) {
    this._rows = rows;
  }

  bool isSetRows() => this.rows != null;

  unsetRows() {
    this.rows = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      case TABLE_NAME:
        return this.table_name;
      case ROWS:
        return this.rows;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      case TABLE_NAME:
        if (value == null) {
          unsetTable_name();
        } else {
          this.table_name = value;
        }
        break;

      case ROWS:
        if (value == null) {
          unsetRows();
        } else {
          this.rows = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      case TABLE_NAME:
        return isSetTable_name();
      case ROWS:
        return isSetRows();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case TABLE_NAME:
          if (field.type == TType.STRING) {
            this.table_name = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ROWS:
          if (field.type == TType.LIST) {
            {
              TList _list126 = iprot.readListBegin();
              this.rows = new List<TStringRow>();
              for (int _i127 = 0; _i127 < _list126.length; ++_i127) {
                TStringRow _elem128;
                _elem128 = new TStringRow();
                _elem128.read(iprot);
                this.rows.add(_elem128);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    if (this.table_name != null) {
      oprot.writeFieldBegin(_TABLE_NAME_FIELD_DESC);
      oprot.writeString(this.table_name);
      oprot.writeFieldEnd();
    }
    if (this.rows != null) {
      oprot.writeFieldBegin(_ROWS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.rows.length));
        for (var elem129 in this.rows) {
          elem129.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("load_table_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(", ");
    ret.write("table_name:");
    if (this.table_name == null) {
      ret.write("null");
    } else {
      ret.write(this.table_name);
    }

    ret.write(", ");
    ret.write("rows:");
    if (this.rows == null) {
      ret.write("null");
    } else {
      ret.write(this.rows);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class load_table_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("load_table_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TMapDException _e;
  static const int E = 1;


  load_table_result() {
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("load_table_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class detect_column_types_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("detect_column_types_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);
  static final TField _FILE_NAME_FIELD_DESC = new TField("file_name", TType.STRING, 2);
  static final TField _COPY_PARAMS_FIELD_DESC = new TField("copy_params", TType.STRUCT, 3);

  String _session;
  static const int SESSION = 1;
  String _file_name;
  static const int FILE_NAME = 2;
  TCopyParams _copy_params;
  static const int COPY_PARAMS = 3;


  detect_column_types_args() {
  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  // file_name
  String get file_name => this._file_name;

  set file_name(String file_name) {
    this._file_name = file_name;
  }

  bool isSetFile_name() => this.file_name != null;

  unsetFile_name() {
    this.file_name = null;
  }

  // copy_params
  TCopyParams get copy_params => this._copy_params;

  set copy_params(TCopyParams copy_params) {
    this._copy_params = copy_params;
  }

  bool isSetCopy_params() => this.copy_params != null;

  unsetCopy_params() {
    this.copy_params = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      case FILE_NAME:
        return this.file_name;
      case COPY_PARAMS:
        return this.copy_params;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      case FILE_NAME:
        if (value == null) {
          unsetFile_name();
        } else {
          this.file_name = value;
        }
        break;

      case COPY_PARAMS:
        if (value == null) {
          unsetCopy_params();
        } else {
          this.copy_params = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      case FILE_NAME:
        return isSetFile_name();
      case COPY_PARAMS:
        return isSetCopy_params();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case FILE_NAME:
          if (field.type == TType.STRING) {
            this.file_name = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case COPY_PARAMS:
          if (field.type == TType.STRUCT) {
            this.copy_params = new TCopyParams();
            this.copy_params.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    if (this.file_name != null) {
      oprot.writeFieldBegin(_FILE_NAME_FIELD_DESC);
      oprot.writeString(this.file_name);
      oprot.writeFieldEnd();
    }
    if (this.copy_params != null) {
      oprot.writeFieldBegin(_COPY_PARAMS_FIELD_DESC);
      this.copy_params.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("detect_column_types_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(", ");
    ret.write("file_name:");
    if (this.file_name == null) {
      ret.write("null");
    } else {
      ret.write(this.file_name);
    }

    ret.write(", ");
    ret.write("copy_params:");
    if (this.copy_params == null) {
      ret.write("null");
    } else {
      ret.write(this.copy_params);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class detect_column_types_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("detect_column_types_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TDetectResult _success;
  static const int SUCCESS = 0;
  TMapDException _e;
  static const int E = 1;


  detect_column_types_result() {
  }

  // success
  TDetectResult get success => this._success;

  set success(TDetectResult success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new TDetectResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("detect_column_types_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class create_table_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("create_table_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);
  static final TField _TABLE_NAME_FIELD_DESC = new TField("table_name", TType.STRING, 2);
  static final TField _ROW_DESC_FIELD_DESC = new TField("row_desc", TType.LIST, 3);
  static final TField _TABLE_TYPE_FIELD_DESC = new TField("table_type", TType.I32, 4);

  String _session;
  static const int SESSION = 1;
  String _table_name;
  static const int TABLE_NAME = 2;
  List<TColumnType> _row_desc;
  static const int ROW_DESC = 3;
  int _table_type;
  static const int TABLE_TYPE = 4;

  bool __isset_table_type = false;

  create_table_args() {
    this.table_type = 0;

  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  // table_name
  String get table_name => this._table_name;

  set table_name(String table_name) {
    this._table_name = table_name;
  }

  bool isSetTable_name() => this.table_name != null;

  unsetTable_name() {
    this.table_name = null;
  }

  // row_desc
  List<TColumnType> get row_desc => this._row_desc;

  set row_desc(List<TColumnType> row_desc) {
    this._row_desc = row_desc;
  }

  bool isSetRow_desc() => this.row_desc != null;

  unsetRow_desc() {
    this.row_desc = null;
  }

  // table_type
  int get table_type => this._table_type;

  set table_type(int table_type) {
    this._table_type = table_type;
    this.__isset_table_type = true;
  }

  bool isSetTable_type() => this.__isset_table_type;

  unsetTable_type() {
    this.__isset_table_type = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      case TABLE_NAME:
        return this.table_name;
      case ROW_DESC:
        return this.row_desc;
      case TABLE_TYPE:
        return this.table_type;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      case TABLE_NAME:
        if (value == null) {
          unsetTable_name();
        } else {
          this.table_name = value;
        }
        break;

      case ROW_DESC:
        if (value == null) {
          unsetRow_desc();
        } else {
          this.row_desc = value;
        }
        break;

      case TABLE_TYPE:
        if (value == null) {
          unsetTable_type();
        } else {
          this.table_type = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      case TABLE_NAME:
        return isSetTable_name();
      case ROW_DESC:
        return isSetRow_desc();
      case TABLE_TYPE:
        return isSetTable_type();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case TABLE_NAME:
          if (field.type == TType.STRING) {
            this.table_name = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ROW_DESC:
          if (field.type == TType.LIST) {
            {
              TList _list130 = iprot.readListBegin();
              this.row_desc = new List<TColumnType>();
              for (int _i131 = 0; _i131 < _list130.length; ++_i131) {
                TColumnType _elem132;
                _elem132 = new TColumnType();
                _elem132.read(iprot);
                this.row_desc.add(_elem132);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case TABLE_TYPE:
          if (field.type == TType.I32) {
            this.table_type = iprot.readI32();
            this.__isset_table_type = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    if (this.table_name != null) {
      oprot.writeFieldBegin(_TABLE_NAME_FIELD_DESC);
      oprot.writeString(this.table_name);
      oprot.writeFieldEnd();
    }
    if (this.row_desc != null) {
      oprot.writeFieldBegin(_ROW_DESC_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.row_desc.length));
        for (var elem133 in this.row_desc) {
          elem133.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_TABLE_TYPE_FIELD_DESC);
    oprot.writeI32(this.table_type);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("create_table_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(", ");
    ret.write("table_name:");
    if (this.table_name == null) {
      ret.write("null");
    } else {
      ret.write(this.table_name);
    }

    ret.write(", ");
    ret.write("row_desc:");
    if (this.row_desc == null) {
      ret.write("null");
    } else {
      ret.write(this.row_desc);
    }

    ret.write(", ");
    ret.write("table_type:");
    String table_type_name = TTableType.VALUES_TO_NAMES[this.table_type];
    if (table_type_name != null) {
      ret.write(table_type_name);
      ret.write(" (");
    }
    ret.write(this.table_type);
    if (table_type_name != null) {
      ret.write(")");
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
    if (isSetTable_type() && !TTableType.VALID_VALUES.contains(table_type)) {
      throw new TProtocolError(TProtocolErrorType.UNKNOWN, "The field 'table_type' has been assigned the invalid value $table_type");
    }
  }

}

class create_table_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("create_table_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TMapDException _e;
  static const int E = 1;


  create_table_result() {
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("create_table_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class import_table_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("import_table_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);
  static final TField _TABLE_NAME_FIELD_DESC = new TField("table_name", TType.STRING, 2);
  static final TField _FILE_NAME_FIELD_DESC = new TField("file_name", TType.STRING, 3);
  static final TField _COPY_PARAMS_FIELD_DESC = new TField("copy_params", TType.STRUCT, 4);

  String _session;
  static const int SESSION = 1;
  String _table_name;
  static const int TABLE_NAME = 2;
  String _file_name;
  static const int FILE_NAME = 3;
  TCopyParams _copy_params;
  static const int COPY_PARAMS = 4;


  import_table_args() {
  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  // table_name
  String get table_name => this._table_name;

  set table_name(String table_name) {
    this._table_name = table_name;
  }

  bool isSetTable_name() => this.table_name != null;

  unsetTable_name() {
    this.table_name = null;
  }

  // file_name
  String get file_name => this._file_name;

  set file_name(String file_name) {
    this._file_name = file_name;
  }

  bool isSetFile_name() => this.file_name != null;

  unsetFile_name() {
    this.file_name = null;
  }

  // copy_params
  TCopyParams get copy_params => this._copy_params;

  set copy_params(TCopyParams copy_params) {
    this._copy_params = copy_params;
  }

  bool isSetCopy_params() => this.copy_params != null;

  unsetCopy_params() {
    this.copy_params = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      case TABLE_NAME:
        return this.table_name;
      case FILE_NAME:
        return this.file_name;
      case COPY_PARAMS:
        return this.copy_params;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      case TABLE_NAME:
        if (value == null) {
          unsetTable_name();
        } else {
          this.table_name = value;
        }
        break;

      case FILE_NAME:
        if (value == null) {
          unsetFile_name();
        } else {
          this.file_name = value;
        }
        break;

      case COPY_PARAMS:
        if (value == null) {
          unsetCopy_params();
        } else {
          this.copy_params = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      case TABLE_NAME:
        return isSetTable_name();
      case FILE_NAME:
        return isSetFile_name();
      case COPY_PARAMS:
        return isSetCopy_params();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case TABLE_NAME:
          if (field.type == TType.STRING) {
            this.table_name = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case FILE_NAME:
          if (field.type == TType.STRING) {
            this.file_name = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case COPY_PARAMS:
          if (field.type == TType.STRUCT) {
            this.copy_params = new TCopyParams();
            this.copy_params.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    if (this.table_name != null) {
      oprot.writeFieldBegin(_TABLE_NAME_FIELD_DESC);
      oprot.writeString(this.table_name);
      oprot.writeFieldEnd();
    }
    if (this.file_name != null) {
      oprot.writeFieldBegin(_FILE_NAME_FIELD_DESC);
      oprot.writeString(this.file_name);
      oprot.writeFieldEnd();
    }
    if (this.copy_params != null) {
      oprot.writeFieldBegin(_COPY_PARAMS_FIELD_DESC);
      this.copy_params.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("import_table_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(", ");
    ret.write("table_name:");
    if (this.table_name == null) {
      ret.write("null");
    } else {
      ret.write(this.table_name);
    }

    ret.write(", ");
    ret.write("file_name:");
    if (this.file_name == null) {
      ret.write("null");
    } else {
      ret.write(this.file_name);
    }

    ret.write(", ");
    ret.write("copy_params:");
    if (this.copy_params == null) {
      ret.write("null");
    } else {
      ret.write(this.copy_params);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class import_table_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("import_table_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TMapDException _e;
  static const int E = 1;


  import_table_result() {
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("import_table_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class import_geo_table_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("import_geo_table_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);
  static final TField _TABLE_NAME_FIELD_DESC = new TField("table_name", TType.STRING, 2);
  static final TField _FILE_NAME_FIELD_DESC = new TField("file_name", TType.STRING, 3);
  static final TField _COPY_PARAMS_FIELD_DESC = new TField("copy_params", TType.STRUCT, 4);
  static final TField _ROW_DESC_FIELD_DESC = new TField("row_desc", TType.LIST, 5);

  String _session;
  static const int SESSION = 1;
  String _table_name;
  static const int TABLE_NAME = 2;
  String _file_name;
  static const int FILE_NAME = 3;
  TCopyParams _copy_params;
  static const int COPY_PARAMS = 4;
  List<TColumnType> _row_desc;
  static const int ROW_DESC = 5;


  import_geo_table_args() {
  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  // table_name
  String get table_name => this._table_name;

  set table_name(String table_name) {
    this._table_name = table_name;
  }

  bool isSetTable_name() => this.table_name != null;

  unsetTable_name() {
    this.table_name = null;
  }

  // file_name
  String get file_name => this._file_name;

  set file_name(String file_name) {
    this._file_name = file_name;
  }

  bool isSetFile_name() => this.file_name != null;

  unsetFile_name() {
    this.file_name = null;
  }

  // copy_params
  TCopyParams get copy_params => this._copy_params;

  set copy_params(TCopyParams copy_params) {
    this._copy_params = copy_params;
  }

  bool isSetCopy_params() => this.copy_params != null;

  unsetCopy_params() {
    this.copy_params = null;
  }

  // row_desc
  List<TColumnType> get row_desc => this._row_desc;

  set row_desc(List<TColumnType> row_desc) {
    this._row_desc = row_desc;
  }

  bool isSetRow_desc() => this.row_desc != null;

  unsetRow_desc() {
    this.row_desc = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      case TABLE_NAME:
        return this.table_name;
      case FILE_NAME:
        return this.file_name;
      case COPY_PARAMS:
        return this.copy_params;
      case ROW_DESC:
        return this.row_desc;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      case TABLE_NAME:
        if (value == null) {
          unsetTable_name();
        } else {
          this.table_name = value;
        }
        break;

      case FILE_NAME:
        if (value == null) {
          unsetFile_name();
        } else {
          this.file_name = value;
        }
        break;

      case COPY_PARAMS:
        if (value == null) {
          unsetCopy_params();
        } else {
          this.copy_params = value;
        }
        break;

      case ROW_DESC:
        if (value == null) {
          unsetRow_desc();
        } else {
          this.row_desc = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      case TABLE_NAME:
        return isSetTable_name();
      case FILE_NAME:
        return isSetFile_name();
      case COPY_PARAMS:
        return isSetCopy_params();
      case ROW_DESC:
        return isSetRow_desc();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case TABLE_NAME:
          if (field.type == TType.STRING) {
            this.table_name = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case FILE_NAME:
          if (field.type == TType.STRING) {
            this.file_name = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case COPY_PARAMS:
          if (field.type == TType.STRUCT) {
            this.copy_params = new TCopyParams();
            this.copy_params.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ROW_DESC:
          if (field.type == TType.LIST) {
            {
              TList _list134 = iprot.readListBegin();
              this.row_desc = new List<TColumnType>();
              for (int _i135 = 0; _i135 < _list134.length; ++_i135) {
                TColumnType _elem136;
                _elem136 = new TColumnType();
                _elem136.read(iprot);
                this.row_desc.add(_elem136);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    if (this.table_name != null) {
      oprot.writeFieldBegin(_TABLE_NAME_FIELD_DESC);
      oprot.writeString(this.table_name);
      oprot.writeFieldEnd();
    }
    if (this.file_name != null) {
      oprot.writeFieldBegin(_FILE_NAME_FIELD_DESC);
      oprot.writeString(this.file_name);
      oprot.writeFieldEnd();
    }
    if (this.copy_params != null) {
      oprot.writeFieldBegin(_COPY_PARAMS_FIELD_DESC);
      this.copy_params.write(oprot);
      oprot.writeFieldEnd();
    }
    if (this.row_desc != null) {
      oprot.writeFieldBegin(_ROW_DESC_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.row_desc.length));
        for (var elem137 in this.row_desc) {
          elem137.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("import_geo_table_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(", ");
    ret.write("table_name:");
    if (this.table_name == null) {
      ret.write("null");
    } else {
      ret.write(this.table_name);
    }

    ret.write(", ");
    ret.write("file_name:");
    if (this.file_name == null) {
      ret.write("null");
    } else {
      ret.write(this.file_name);
    }

    ret.write(", ");
    ret.write("copy_params:");
    if (this.copy_params == null) {
      ret.write("null");
    } else {
      ret.write(this.copy_params);
    }

    ret.write(", ");
    ret.write("row_desc:");
    if (this.row_desc == null) {
      ret.write("null");
    } else {
      ret.write(this.row_desc);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class import_geo_table_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("import_geo_table_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TMapDException _e;
  static const int E = 1;


  import_geo_table_result() {
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("import_geo_table_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class import_table_status_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("import_table_status_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);
  static final TField _IMPORT_ID_FIELD_DESC = new TField("import_id", TType.STRING, 2);

  String _session;
  static const int SESSION = 1;
  String _import_id;
  static const int IMPORT_ID = 2;


  import_table_status_args() {
  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  // import_id
  String get import_id => this._import_id;

  set import_id(String import_id) {
    this._import_id = import_id;
  }

  bool isSetImport_id() => this.import_id != null;

  unsetImport_id() {
    this.import_id = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      case IMPORT_ID:
        return this.import_id;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      case IMPORT_ID:
        if (value == null) {
          unsetImport_id();
        } else {
          this.import_id = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      case IMPORT_ID:
        return isSetImport_id();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case IMPORT_ID:
          if (field.type == TType.STRING) {
            this.import_id = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    if (this.import_id != null) {
      oprot.writeFieldBegin(_IMPORT_ID_FIELD_DESC);
      oprot.writeString(this.import_id);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("import_table_status_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(", ");
    ret.write("import_id:");
    if (this.import_id == null) {
      ret.write("null");
    } else {
      ret.write(this.import_id);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class import_table_status_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("import_table_status_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TImportStatus _success;
  static const int SUCCESS = 0;
  TMapDException _e;
  static const int E = 1;


  import_table_status_result() {
  }

  // success
  TImportStatus get success => this._success;

  set success(TImportStatus success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new TImportStatus();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("import_table_status_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class start_query_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("start_query_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);
  static final TField _QUERY_RA_FIELD_DESC = new TField("query_ra", TType.STRING, 2);
  static final TField _JUST_EXPLAIN_FIELD_DESC = new TField("just_explain", TType.BOOL, 3);

  String _session;
  static const int SESSION = 1;
  String _query_ra;
  static const int QUERY_RA = 2;
  bool _just_explain = false;
  static const int JUST_EXPLAIN = 3;

  bool __isset_just_explain = false;

  start_query_args() {
  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  // query_ra
  String get query_ra => this._query_ra;

  set query_ra(String query_ra) {
    this._query_ra = query_ra;
  }

  bool isSetQuery_ra() => this.query_ra != null;

  unsetQuery_ra() {
    this.query_ra = null;
  }

  // just_explain
  bool get just_explain => this._just_explain;

  set just_explain(bool just_explain) {
    this._just_explain = just_explain;
    this.__isset_just_explain = true;
  }

  bool isSetJust_explain() => this.__isset_just_explain;

  unsetJust_explain() {
    this.__isset_just_explain = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      case QUERY_RA:
        return this.query_ra;
      case JUST_EXPLAIN:
        return this.just_explain;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      case QUERY_RA:
        if (value == null) {
          unsetQuery_ra();
        } else {
          this.query_ra = value;
        }
        break;

      case JUST_EXPLAIN:
        if (value == null) {
          unsetJust_explain();
        } else {
          this.just_explain = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      case QUERY_RA:
        return isSetQuery_ra();
      case JUST_EXPLAIN:
        return isSetJust_explain();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case QUERY_RA:
          if (field.type == TType.STRING) {
            this.query_ra = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case JUST_EXPLAIN:
          if (field.type == TType.BOOL) {
            this.just_explain = iprot.readBool();
            this.__isset_just_explain = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    if (this.query_ra != null) {
      oprot.writeFieldBegin(_QUERY_RA_FIELD_DESC);
      oprot.writeString(this.query_ra);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_JUST_EXPLAIN_FIELD_DESC);
    oprot.writeBool(this.just_explain);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("start_query_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(", ");
    ret.write("query_ra:");
    if (this.query_ra == null) {
      ret.write("null");
    } else {
      ret.write(this.query_ra);
    }

    ret.write(", ");
    ret.write("just_explain:");
    ret.write(this.just_explain);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class start_query_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("start_query_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TPendingQuery _success;
  static const int SUCCESS = 0;
  TMapDException _e;
  static const int E = 1;


  start_query_result() {
  }

  // success
  TPendingQuery get success => this._success;

  set success(TPendingQuery success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new TPendingQuery();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("start_query_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class execute_first_step_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("execute_first_step_args");
  static final TField _PENDING_QUERY_FIELD_DESC = new TField("pending_query", TType.STRUCT, 1);

  TPendingQuery _pending_query;
  static const int PENDING_QUERY = 1;


  execute_first_step_args() {
  }

  // pending_query
  TPendingQuery get pending_query => this._pending_query;

  set pending_query(TPendingQuery pending_query) {
    this._pending_query = pending_query;
  }

  bool isSetPending_query() => this.pending_query != null;

  unsetPending_query() {
    this.pending_query = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case PENDING_QUERY:
        return this.pending_query;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case PENDING_QUERY:
        if (value == null) {
          unsetPending_query();
        } else {
          this.pending_query = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case PENDING_QUERY:
        return isSetPending_query();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case PENDING_QUERY:
          if (field.type == TType.STRUCT) {
            this.pending_query = new TPendingQuery();
            this.pending_query.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.pending_query != null) {
      oprot.writeFieldBegin(_PENDING_QUERY_FIELD_DESC);
      this.pending_query.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("execute_first_step_args(");

    ret.write("pending_query:");
    if (this.pending_query == null) {
      ret.write("null");
    } else {
      ret.write(this.pending_query);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class execute_first_step_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("execute_first_step_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TStepResult _success;
  static const int SUCCESS = 0;
  TMapDException _e;
  static const int E = 1;


  execute_first_step_result() {
  }

  // success
  TStepResult get success => this._success;

  set success(TStepResult success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new TStepResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("execute_first_step_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class broadcast_serialized_rows_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("broadcast_serialized_rows_args");
  static final TField _SERIALIZED_ROWS_FIELD_DESC = new TField("serialized_rows", TType.STRING, 1);
  static final TField _ROW_DESC_FIELD_DESC = new TField("row_desc", TType.LIST, 2);
  static final TField _QUERY_ID_FIELD_DESC = new TField("query_id", TType.I64, 3);

  String _serialized_rows;
  static const int SERIALIZED_ROWS = 1;
  List<TColumnType> _row_desc;
  static const int ROW_DESC = 2;
  int _query_id = 0;
  static const int QUERY_ID = 3;

  bool __isset_query_id = false;

  broadcast_serialized_rows_args() {
  }

  // serialized_rows
  String get serialized_rows => this._serialized_rows;

  set serialized_rows(String serialized_rows) {
    this._serialized_rows = serialized_rows;
  }

  bool isSetSerialized_rows() => this.serialized_rows != null;

  unsetSerialized_rows() {
    this.serialized_rows = null;
  }

  // row_desc
  List<TColumnType> get row_desc => this._row_desc;

  set row_desc(List<TColumnType> row_desc) {
    this._row_desc = row_desc;
  }

  bool isSetRow_desc() => this.row_desc != null;

  unsetRow_desc() {
    this.row_desc = null;
  }

  // query_id
  int get query_id => this._query_id;

  set query_id(int query_id) {
    this._query_id = query_id;
    this.__isset_query_id = true;
  }

  bool isSetQuery_id() => this.__isset_query_id;

  unsetQuery_id() {
    this.__isset_query_id = false;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SERIALIZED_ROWS:
        return this.serialized_rows;
      case ROW_DESC:
        return this.row_desc;
      case QUERY_ID:
        return this.query_id;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SERIALIZED_ROWS:
        if (value == null) {
          unsetSerialized_rows();
        } else {
          this.serialized_rows = value;
        }
        break;

      case ROW_DESC:
        if (value == null) {
          unsetRow_desc();
        } else {
          this.row_desc = value;
        }
        break;

      case QUERY_ID:
        if (value == null) {
          unsetQuery_id();
        } else {
          this.query_id = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SERIALIZED_ROWS:
        return isSetSerialized_rows();
      case ROW_DESC:
        return isSetRow_desc();
      case QUERY_ID:
        return isSetQuery_id();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SERIALIZED_ROWS:
          if (field.type == TType.STRING) {
            this.serialized_rows = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ROW_DESC:
          if (field.type == TType.LIST) {
            {
              TList _list138 = iprot.readListBegin();
              this.row_desc = new List<TColumnType>();
              for (int _i139 = 0; _i139 < _list138.length; ++_i139) {
                TColumnType _elem140;
                _elem140 = new TColumnType();
                _elem140.read(iprot);
                this.row_desc.add(_elem140);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case QUERY_ID:
          if (field.type == TType.I64) {
            this.query_id = iprot.readI64();
            this.__isset_query_id = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.serialized_rows != null) {
      oprot.writeFieldBegin(_SERIALIZED_ROWS_FIELD_DESC);
      oprot.writeString(this.serialized_rows);
      oprot.writeFieldEnd();
    }
    if (this.row_desc != null) {
      oprot.writeFieldBegin(_ROW_DESC_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.row_desc.length));
        for (var elem141 in this.row_desc) {
          elem141.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_QUERY_ID_FIELD_DESC);
    oprot.writeI64(this.query_id);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("broadcast_serialized_rows_args(");

    ret.write("serialized_rows:");
    if (this.serialized_rows == null) {
      ret.write("null");
    } else {
      ret.write(this.serialized_rows);
    }

    ret.write(", ");
    ret.write("row_desc:");
    if (this.row_desc == null) {
      ret.write("null");
    } else {
      ret.write(this.row_desc);
    }

    ret.write(", ");
    ret.write("query_id:");
    ret.write(this.query_id);

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class broadcast_serialized_rows_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("broadcast_serialized_rows_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TMapDException _e;
  static const int E = 1;


  broadcast_serialized_rows_result() {
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("broadcast_serialized_rows_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class render_vega_raw_pixels_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("render_vega_raw_pixels_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);
  static final TField _WIDGET_ID_FIELD_DESC = new TField("widget_id", TType.I64, 2);
  static final TField _NODE_IDX_FIELD_DESC = new TField("node_idx", TType.I16, 3);
  static final TField _VEGA_JSON_FIELD_DESC = new TField("vega_json", TType.STRING, 4);

  String _session;
  static const int SESSION = 1;
  int _widget_id = 0;
  static const int WIDGET_ID = 2;
  int _node_idx = 0;
  static const int NODE_IDX = 3;
  String _vega_json;
  static const int VEGA_JSON = 4;

  bool __isset_widget_id = false;
  bool __isset_node_idx = false;

  render_vega_raw_pixels_args() {
  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  // widget_id
  int get widget_id => this._widget_id;

  set widget_id(int widget_id) {
    this._widget_id = widget_id;
    this.__isset_widget_id = true;
  }

  bool isSetWidget_id() => this.__isset_widget_id;

  unsetWidget_id() {
    this.__isset_widget_id = false;
  }

  // node_idx
  int get node_idx => this._node_idx;

  set node_idx(int node_idx) {
    this._node_idx = node_idx;
    this.__isset_node_idx = true;
  }

  bool isSetNode_idx() => this.__isset_node_idx;

  unsetNode_idx() {
    this.__isset_node_idx = false;
  }

  // vega_json
  String get vega_json => this._vega_json;

  set vega_json(String vega_json) {
    this._vega_json = vega_json;
  }

  bool isSetVega_json() => this.vega_json != null;

  unsetVega_json() {
    this.vega_json = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      case WIDGET_ID:
        return this.widget_id;
      case NODE_IDX:
        return this.node_idx;
      case VEGA_JSON:
        return this.vega_json;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      case WIDGET_ID:
        if (value == null) {
          unsetWidget_id();
        } else {
          this.widget_id = value;
        }
        break;

      case NODE_IDX:
        if (value == null) {
          unsetNode_idx();
        } else {
          this.node_idx = value;
        }
        break;

      case VEGA_JSON:
        if (value == null) {
          unsetVega_json();
        } else {
          this.vega_json = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      case WIDGET_ID:
        return isSetWidget_id();
      case NODE_IDX:
        return isSetNode_idx();
      case VEGA_JSON:
        return isSetVega_json();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case WIDGET_ID:
          if (field.type == TType.I64) {
            this.widget_id = iprot.readI64();
            this.__isset_widget_id = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NODE_IDX:
          if (field.type == TType.I16) {
            this.node_idx = iprot.readI16();
            this.__isset_node_idx = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case VEGA_JSON:
          if (field.type == TType.STRING) {
            this.vega_json = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_WIDGET_ID_FIELD_DESC);
    oprot.writeI64(this.widget_id);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_NODE_IDX_FIELD_DESC);
    oprot.writeI16(this.node_idx);
    oprot.writeFieldEnd();
    if (this.vega_json != null) {
      oprot.writeFieldBegin(_VEGA_JSON_FIELD_DESC);
      oprot.writeString(this.vega_json);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("render_vega_raw_pixels_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(", ");
    ret.write("widget_id:");
    ret.write(this.widget_id);

    ret.write(", ");
    ret.write("node_idx:");
    ret.write(this.node_idx);

    ret.write(", ");
    ret.write("vega_json:");
    if (this.vega_json == null) {
      ret.write("null");
    } else {
      ret.write(this.vega_json);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class render_vega_raw_pixels_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("render_vega_raw_pixels_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TRawPixelDataResult _success;
  static const int SUCCESS = 0;
  TMapDException _e;
  static const int E = 1;


  render_vega_raw_pixels_result() {
  }

  // success
  TRawPixelDataResult get success => this._success;

  set success(TRawPixelDataResult success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new TRawPixelDataResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("render_vega_raw_pixels_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class insert_data_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("insert_data_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);
  static final TField _INSERT_DATA_FIELD_DESC = new TField("insert_data", TType.STRUCT, 2);

  String _session;
  static const int SESSION = 1;
  TInsertData _insert_data;
  static const int INSERT_DATA = 2;


  insert_data_args() {
  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  // insert_data
  TInsertData get insert_data => this._insert_data;

  set insert_data(TInsertData insert_data) {
    this._insert_data = insert_data;
  }

  bool isSetInsert_data() => this.insert_data != null;

  unsetInsert_data() {
    this.insert_data = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      case INSERT_DATA:
        return this.insert_data;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      case INSERT_DATA:
        if (value == null) {
          unsetInsert_data();
        } else {
          this.insert_data = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      case INSERT_DATA:
        return isSetInsert_data();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case INSERT_DATA:
          if (field.type == TType.STRUCT) {
            this.insert_data = new TInsertData();
            this.insert_data.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    if (this.insert_data != null) {
      oprot.writeFieldBegin(_INSERT_DATA_FIELD_DESC);
      this.insert_data.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("insert_data_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(", ");
    ret.write("insert_data:");
    if (this.insert_data == null) {
      ret.write("null");
    } else {
      ret.write(this.insert_data);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class insert_data_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("insert_data_result");
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TMapDException _e;
  static const int E = 1;


  insert_data_result() {
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("insert_data_result(");

    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class get_table_descriptor_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("get_table_descriptor_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);
  static final TField _TABLE_NAME_FIELD_DESC = new TField("table_name", TType.STRING, 2);

  String _session;
  static const int SESSION = 1;
  String _table_name;
  static const int TABLE_NAME = 2;


  get_table_descriptor_args() {
  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  // table_name
  String get table_name => this._table_name;

  set table_name(String table_name) {
    this._table_name = table_name;
  }

  bool isSetTable_name() => this.table_name != null;

  unsetTable_name() {
    this.table_name = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      case TABLE_NAME:
        return this.table_name;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      case TABLE_NAME:
        if (value == null) {
          unsetTable_name();
        } else {
          this.table_name = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      case TABLE_NAME:
        return isSetTable_name();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case TABLE_NAME:
          if (field.type == TType.STRING) {
            this.table_name = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    if (this.table_name != null) {
      oprot.writeFieldBegin(_TABLE_NAME_FIELD_DESC);
      oprot.writeString(this.table_name);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("get_table_descriptor_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(", ");
    ret.write("table_name:");
    if (this.table_name == null) {
      ret.write("null");
    } else {
      ret.write(this.table_name);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class get_table_descriptor_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("get_table_descriptor_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.MAP, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  Map<String, TColumnType> _success;
  static const int SUCCESS = 0;
  TMapDException _e;
  static const int E = 1;


  get_table_descriptor_result() {
  }

  // success
  Map<String, TColumnType> get success => this._success;

  set success(Map<String, TColumnType> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.MAP) {
            {
              TMap _map142 = iprot.readMapBegin();
              this.success = new Map<String, TColumnType>();
              for (int _i143 = 0; _i143 < _map142.length; ++_i143) {
                String _key144;
                TColumnType _val145;
                _key144 = iprot.readString();
                _val145 = new TColumnType();
                _val145.read(iprot);
                this.success[_key144] = _val145;
              }
              iprot.readMapEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeMapBegin(new TMap(TType.STRING, TType.STRUCT, this.success.length));
        for (var elem147 in this.success.keys) {
          oprot.writeString(elem147);
          this.success[elem147].write(oprot);
        }
        oprot.writeMapEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("get_table_descriptor_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class get_row_descriptor_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("get_row_descriptor_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);
  static final TField _TABLE_NAME_FIELD_DESC = new TField("table_name", TType.STRING, 2);

  String _session;
  static const int SESSION = 1;
  String _table_name;
  static const int TABLE_NAME = 2;


  get_row_descriptor_args() {
  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  // table_name
  String get table_name => this._table_name;

  set table_name(String table_name) {
    this._table_name = table_name;
  }

  bool isSetTable_name() => this.table_name != null;

  unsetTable_name() {
    this.table_name = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      case TABLE_NAME:
        return this.table_name;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      case TABLE_NAME:
        if (value == null) {
          unsetTable_name();
        } else {
          this.table_name = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      case TABLE_NAME:
        return isSetTable_name();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case TABLE_NAME:
          if (field.type == TType.STRING) {
            this.table_name = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    if (this.table_name != null) {
      oprot.writeFieldBegin(_TABLE_NAME_FIELD_DESC);
      oprot.writeString(this.table_name);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("get_row_descriptor_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(", ");
    ret.write("table_name:");
    if (this.table_name == null) {
      ret.write("null");
    } else {
      ret.write(this.table_name);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class get_row_descriptor_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("get_row_descriptor_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.LIST, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  List<TColumnType> _success;
  static const int SUCCESS = 0;
  TMapDException _e;
  static const int E = 1;


  get_row_descriptor_result() {
  }

  // success
  List<TColumnType> get success => this._success;

  set success(List<TColumnType> success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              TList _list148 = iprot.readListBegin();
              this.success = new List<TColumnType>();
              for (int _i149 = 0; _i149 < _list148.length; ++_i149) {
                TColumnType _elem150;
                _elem150 = new TColumnType();
                _elem150.read(iprot);
                this.success.add(_elem150);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for (var elem151 in this.success) {
          elem151.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("get_row_descriptor_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class render_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("render_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);
  static final TField _QUERY_FIELD_DESC = new TField("query", TType.STRING, 2);
  static final TField _RENDER_TYPE_FIELD_DESC = new TField("render_type", TType.STRING, 3);
  static final TField _NONCE_FIELD_DESC = new TField("nonce", TType.STRING, 4);

  String _session;
  static const int SESSION = 1;
  String _query;
  static const int QUERY = 2;
  String _render_type;
  static const int RENDER_TYPE = 3;
  String _nonce;
  static const int NONCE = 4;


  render_args() {
  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  // query
  String get query => this._query;

  set query(String query) {
    this._query = query;
  }

  bool isSetQuery() => this.query != null;

  unsetQuery() {
    this.query = null;
  }

  // render_type
  String get render_type => this._render_type;

  set render_type(String render_type) {
    this._render_type = render_type;
  }

  bool isSetRender_type() => this.render_type != null;

  unsetRender_type() {
    this.render_type = null;
  }

  // nonce
  String get nonce => this._nonce;

  set nonce(String nonce) {
    this._nonce = nonce;
  }

  bool isSetNonce() => this.nonce != null;

  unsetNonce() {
    this.nonce = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      case QUERY:
        return this.query;
      case RENDER_TYPE:
        return this.render_type;
      case NONCE:
        return this.nonce;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      case QUERY:
        if (value == null) {
          unsetQuery();
        } else {
          this.query = value;
        }
        break;

      case RENDER_TYPE:
        if (value == null) {
          unsetRender_type();
        } else {
          this.render_type = value;
        }
        break;

      case NONCE:
        if (value == null) {
          unsetNonce();
        } else {
          this.nonce = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      case QUERY:
        return isSetQuery();
      case RENDER_TYPE:
        return isSetRender_type();
      case NONCE:
        return isSetNonce();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case QUERY:
          if (field.type == TType.STRING) {
            this.query = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case RENDER_TYPE:
          if (field.type == TType.STRING) {
            this.render_type = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NONCE:
          if (field.type == TType.STRING) {
            this.nonce = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    if (this.query != null) {
      oprot.writeFieldBegin(_QUERY_FIELD_DESC);
      oprot.writeString(this.query);
      oprot.writeFieldEnd();
    }
    if (this.render_type != null) {
      oprot.writeFieldBegin(_RENDER_TYPE_FIELD_DESC);
      oprot.writeString(this.render_type);
      oprot.writeFieldEnd();
    }
    if (this.nonce != null) {
      oprot.writeFieldBegin(_NONCE_FIELD_DESC);
      oprot.writeString(this.nonce);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("render_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(", ");
    ret.write("query:");
    if (this.query == null) {
      ret.write("null");
    } else {
      ret.write(this.query);
    }

    ret.write(", ");
    ret.write("render_type:");
    if (this.render_type == null) {
      ret.write("null");
    } else {
      ret.write(this.render_type);
    }

    ret.write(", ");
    ret.write("nonce:");
    if (this.nonce == null) {
      ret.write("null");
    } else {
      ret.write(this.nonce);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class render_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("render_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TRenderResult _success;
  static const int SUCCESS = 0;
  TMapDException _e;
  static const int E = 1;


  render_result() {
  }

  // success
  TRenderResult get success => this._success;

  set success(TRenderResult success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new TRenderResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("render_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class get_rows_for_pixels_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("get_rows_for_pixels_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);
  static final TField _WIDGET_ID_FIELD_DESC = new TField("widget_id", TType.I64, 2);
  static final TField _PIXELS_FIELD_DESC = new TField("pixels", TType.LIST, 3);
  static final TField _TABLE_NAME_FIELD_DESC = new TField("table_name", TType.STRING, 4);
  static final TField _COL_NAMES_FIELD_DESC = new TField("col_names", TType.LIST, 5);
  static final TField _COLUMN_FORMAT_FIELD_DESC = new TField("column_format", TType.BOOL, 6);
  static final TField _NONCE_FIELD_DESC = new TField("nonce", TType.STRING, 7);

  String _session;
  static const int SESSION = 1;
  int _widget_id = 0;
  static const int WIDGET_ID = 2;
  List<TPixel> _pixels;
  static const int PIXELS = 3;
  String _table_name;
  static const int TABLE_NAME = 4;
  List<String> _col_names;
  static const int COL_NAMES = 5;
  bool _column_format = false;
  static const int COLUMN_FORMAT = 6;
  String _nonce;
  static const int NONCE = 7;

  bool __isset_widget_id = false;
  bool __isset_column_format = false;

  get_rows_for_pixels_args() {
  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  // widget_id
  int get widget_id => this._widget_id;

  set widget_id(int widget_id) {
    this._widget_id = widget_id;
    this.__isset_widget_id = true;
  }

  bool isSetWidget_id() => this.__isset_widget_id;

  unsetWidget_id() {
    this.__isset_widget_id = false;
  }

  // pixels
  List<TPixel> get pixels => this._pixels;

  set pixels(List<TPixel> pixels) {
    this._pixels = pixels;
  }

  bool isSetPixels() => this.pixels != null;

  unsetPixels() {
    this.pixels = null;
  }

  // table_name
  String get table_name => this._table_name;

  set table_name(String table_name) {
    this._table_name = table_name;
  }

  bool isSetTable_name() => this.table_name != null;

  unsetTable_name() {
    this.table_name = null;
  }

  // col_names
  List<String> get col_names => this._col_names;

  set col_names(List<String> col_names) {
    this._col_names = col_names;
  }

  bool isSetCol_names() => this.col_names != null;

  unsetCol_names() {
    this.col_names = null;
  }

  // column_format
  bool get column_format => this._column_format;

  set column_format(bool column_format) {
    this._column_format = column_format;
    this.__isset_column_format = true;
  }

  bool isSetColumn_format() => this.__isset_column_format;

  unsetColumn_format() {
    this.__isset_column_format = false;
  }

  // nonce
  String get nonce => this._nonce;

  set nonce(String nonce) {
    this._nonce = nonce;
  }

  bool isSetNonce() => this.nonce != null;

  unsetNonce() {
    this.nonce = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      case WIDGET_ID:
        return this.widget_id;
      case PIXELS:
        return this.pixels;
      case TABLE_NAME:
        return this.table_name;
      case COL_NAMES:
        return this.col_names;
      case COLUMN_FORMAT:
        return this.column_format;
      case NONCE:
        return this.nonce;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      case WIDGET_ID:
        if (value == null) {
          unsetWidget_id();
        } else {
          this.widget_id = value;
        }
        break;

      case PIXELS:
        if (value == null) {
          unsetPixels();
        } else {
          this.pixels = value;
        }
        break;

      case TABLE_NAME:
        if (value == null) {
          unsetTable_name();
        } else {
          this.table_name = value;
        }
        break;

      case COL_NAMES:
        if (value == null) {
          unsetCol_names();
        } else {
          this.col_names = value;
        }
        break;

      case COLUMN_FORMAT:
        if (value == null) {
          unsetColumn_format();
        } else {
          this.column_format = value;
        }
        break;

      case NONCE:
        if (value == null) {
          unsetNonce();
        } else {
          this.nonce = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      case WIDGET_ID:
        return isSetWidget_id();
      case PIXELS:
        return isSetPixels();
      case TABLE_NAME:
        return isSetTable_name();
      case COL_NAMES:
        return isSetCol_names();
      case COLUMN_FORMAT:
        return isSetColumn_format();
      case NONCE:
        return isSetNonce();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case WIDGET_ID:
          if (field.type == TType.I64) {
            this.widget_id = iprot.readI64();
            this.__isset_widget_id = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PIXELS:
          if (field.type == TType.LIST) {
            {
              TList _list152 = iprot.readListBegin();
              this.pixels = new List<TPixel>();
              for (int _i153 = 0; _i153 < _list152.length; ++_i153) {
                TPixel _elem154;
                _elem154 = new TPixel();
                _elem154.read(iprot);
                this.pixels.add(_elem154);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case TABLE_NAME:
          if (field.type == TType.STRING) {
            this.table_name = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case COL_NAMES:
          if (field.type == TType.LIST) {
            {
              TList _list155 = iprot.readListBegin();
              this.col_names = new List<String>();
              for (int _i156 = 0; _i156 < _list155.length; ++_i156) {
                String _elem157;
                _elem157 = iprot.readString();
                this.col_names.add(_elem157);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case COLUMN_FORMAT:
          if (field.type == TType.BOOL) {
            this.column_format = iprot.readBool();
            this.__isset_column_format = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NONCE:
          if (field.type == TType.STRING) {
            this.nonce = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_WIDGET_ID_FIELD_DESC);
    oprot.writeI64(this.widget_id);
    oprot.writeFieldEnd();
    if (this.pixels != null) {
      oprot.writeFieldBegin(_PIXELS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.pixels.length));
        for (var elem158 in this.pixels) {
          elem158.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    if (this.table_name != null) {
      oprot.writeFieldBegin(_TABLE_NAME_FIELD_DESC);
      oprot.writeString(this.table_name);
      oprot.writeFieldEnd();
    }
    if (this.col_names != null) {
      oprot.writeFieldBegin(_COL_NAMES_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.col_names.length));
        for (var elem159 in this.col_names) {
          oprot.writeString(elem159);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_COLUMN_FORMAT_FIELD_DESC);
    oprot.writeBool(this.column_format);
    oprot.writeFieldEnd();
    if (this.nonce != null) {
      oprot.writeFieldBegin(_NONCE_FIELD_DESC);
      oprot.writeString(this.nonce);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("get_rows_for_pixels_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(", ");
    ret.write("widget_id:");
    ret.write(this.widget_id);

    ret.write(", ");
    ret.write("pixels:");
    if (this.pixels == null) {
      ret.write("null");
    } else {
      ret.write(this.pixels);
    }

    ret.write(", ");
    ret.write("table_name:");
    if (this.table_name == null) {
      ret.write("null");
    } else {
      ret.write(this.table_name);
    }

    ret.write(", ");
    ret.write("col_names:");
    if (this.col_names == null) {
      ret.write("null");
    } else {
      ret.write(this.col_names);
    }

    ret.write(", ");
    ret.write("column_format:");
    ret.write(this.column_format);

    ret.write(", ");
    ret.write("nonce:");
    if (this.nonce == null) {
      ret.write("null");
    } else {
      ret.write(this.nonce);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class get_rows_for_pixels_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("get_rows_for_pixels_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TPixelResult _success;
  static const int SUCCESS = 0;
  TMapDException _e;
  static const int E = 1;


  get_rows_for_pixels_result() {
  }

  // success
  TPixelResult get success => this._success;

  set success(TPixelResult success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new TPixelResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("get_rows_for_pixels_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class get_row_for_pixel_args implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("get_row_for_pixel_args");
  static final TField _SESSION_FIELD_DESC = new TField("session", TType.STRING, 1);
  static final TField _WIDGET_ID_FIELD_DESC = new TField("widget_id", TType.I64, 2);
  static final TField _PIXEL_FIELD_DESC = new TField("pixel", TType.STRUCT, 3);
  static final TField _TABLE_NAME_FIELD_DESC = new TField("table_name", TType.STRING, 4);
  static final TField _COL_NAMES_FIELD_DESC = new TField("col_names", TType.LIST, 5);
  static final TField _COLUMN_FORMAT_FIELD_DESC = new TField("column_format", TType.BOOL, 6);
  static final TField _PIXEL_RADIUS_FIELD_DESC = new TField("pixelRadius", TType.I32, 7);
  static final TField _NONCE_FIELD_DESC = new TField("nonce", TType.STRING, 8);

  String _session;
  static const int SESSION = 1;
  int _widget_id = 0;
  static const int WIDGET_ID = 2;
  TPixel _pixel;
  static const int PIXEL = 3;
  String _table_name;
  static const int TABLE_NAME = 4;
  List<String> _col_names;
  static const int COL_NAMES = 5;
  bool _column_format = false;
  static const int COLUMN_FORMAT = 6;
  int _pixelRadius = 0;
  static const int PIXELRADIUS = 7;
  String _nonce;
  static const int NONCE = 8;

  bool __isset_widget_id = false;
  bool __isset_column_format = false;
  bool __isset_pixelRadius = false;

  get_row_for_pixel_args() {
  }

  // session
  String get session => this._session;

  set session(String session) {
    this._session = session;
  }

  bool isSetSession() => this.session != null;

  unsetSession() {
    this.session = null;
  }

  // widget_id
  int get widget_id => this._widget_id;

  set widget_id(int widget_id) {
    this._widget_id = widget_id;
    this.__isset_widget_id = true;
  }

  bool isSetWidget_id() => this.__isset_widget_id;

  unsetWidget_id() {
    this.__isset_widget_id = false;
  }

  // pixel
  TPixel get pixel => this._pixel;

  set pixel(TPixel pixel) {
    this._pixel = pixel;
  }

  bool isSetPixel() => this.pixel != null;

  unsetPixel() {
    this.pixel = null;
  }

  // table_name
  String get table_name => this._table_name;

  set table_name(String table_name) {
    this._table_name = table_name;
  }

  bool isSetTable_name() => this.table_name != null;

  unsetTable_name() {
    this.table_name = null;
  }

  // col_names
  List<String> get col_names => this._col_names;

  set col_names(List<String> col_names) {
    this._col_names = col_names;
  }

  bool isSetCol_names() => this.col_names != null;

  unsetCol_names() {
    this.col_names = null;
  }

  // column_format
  bool get column_format => this._column_format;

  set column_format(bool column_format) {
    this._column_format = column_format;
    this.__isset_column_format = true;
  }

  bool isSetColumn_format() => this.__isset_column_format;

  unsetColumn_format() {
    this.__isset_column_format = false;
  }

  // pixelRadius
  int get pixelRadius => this._pixelRadius;

  set pixelRadius(int pixelRadius) {
    this._pixelRadius = pixelRadius;
    this.__isset_pixelRadius = true;
  }

  bool isSetPixelRadius() => this.__isset_pixelRadius;

  unsetPixelRadius() {
    this.__isset_pixelRadius = false;
  }

  // nonce
  String get nonce => this._nonce;

  set nonce(String nonce) {
    this._nonce = nonce;
  }

  bool isSetNonce() => this.nonce != null;

  unsetNonce() {
    this.nonce = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return this.session;
      case WIDGET_ID:
        return this.widget_id;
      case PIXEL:
        return this.pixel;
      case TABLE_NAME:
        return this.table_name;
      case COL_NAMES:
        return this.col_names;
      case COLUMN_FORMAT:
        return this.column_format;
      case PIXELRADIUS:
        return this.pixelRadius;
      case NONCE:
        return this.nonce;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SESSION:
        if (value == null) {
          unsetSession();
        } else {
          this.session = value;
        }
        break;

      case WIDGET_ID:
        if (value == null) {
          unsetWidget_id();
        } else {
          this.widget_id = value;
        }
        break;

      case PIXEL:
        if (value == null) {
          unsetPixel();
        } else {
          this.pixel = value;
        }
        break;

      case TABLE_NAME:
        if (value == null) {
          unsetTable_name();
        } else {
          this.table_name = value;
        }
        break;

      case COL_NAMES:
        if (value == null) {
          unsetCol_names();
        } else {
          this.col_names = value;
        }
        break;

      case COLUMN_FORMAT:
        if (value == null) {
          unsetColumn_format();
        } else {
          this.column_format = value;
        }
        break;

      case PIXELRADIUS:
        if (value == null) {
          unsetPixelRadius();
        } else {
          this.pixelRadius = value;
        }
        break;

      case NONCE:
        if (value == null) {
          unsetNonce();
        } else {
          this.nonce = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SESSION:
        return isSetSession();
      case WIDGET_ID:
        return isSetWidget_id();
      case PIXEL:
        return isSetPixel();
      case TABLE_NAME:
        return isSetTable_name();
      case COL_NAMES:
        return isSetCol_names();
      case COLUMN_FORMAT:
        return isSetColumn_format();
      case PIXELRADIUS:
        return isSetPixelRadius();
      case NONCE:
        return isSetNonce();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SESSION:
          if (field.type == TType.STRING) {
            this.session = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case WIDGET_ID:
          if (field.type == TType.I64) {
            this.widget_id = iprot.readI64();
            this.__isset_widget_id = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PIXEL:
          if (field.type == TType.STRUCT) {
            this.pixel = new TPixel();
            this.pixel.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case TABLE_NAME:
          if (field.type == TType.STRING) {
            this.table_name = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case COL_NAMES:
          if (field.type == TType.LIST) {
            {
              TList _list160 = iprot.readListBegin();
              this.col_names = new List<String>();
              for (int _i161 = 0; _i161 < _list160.length; ++_i161) {
                String _elem162;
                _elem162 = iprot.readString();
                this.col_names.add(_elem162);
              }
              iprot.readListEnd();
            }
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case COLUMN_FORMAT:
          if (field.type == TType.BOOL) {
            this.column_format = iprot.readBool();
            this.__isset_column_format = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PIXELRADIUS:
          if (field.type == TType.I32) {
            this.pixelRadius = iprot.readI32();
            this.__isset_pixelRadius = true;
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NONCE:
          if (field.type == TType.STRING) {
            this.nonce = iprot.readString();
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    validate();

    oprot.writeStructBegin(_STRUCT_DESC);
    if (this.session != null) {
      oprot.writeFieldBegin(_SESSION_FIELD_DESC);
      oprot.writeString(this.session);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_WIDGET_ID_FIELD_DESC);
    oprot.writeI64(this.widget_id);
    oprot.writeFieldEnd();
    if (this.pixel != null) {
      oprot.writeFieldBegin(_PIXEL_FIELD_DESC);
      this.pixel.write(oprot);
      oprot.writeFieldEnd();
    }
    if (this.table_name != null) {
      oprot.writeFieldBegin(_TABLE_NAME_FIELD_DESC);
      oprot.writeString(this.table_name);
      oprot.writeFieldEnd();
    }
    if (this.col_names != null) {
      oprot.writeFieldBegin(_COL_NAMES_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.col_names.length));
        for (var elem163 in this.col_names) {
          oprot.writeString(elem163);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(_COLUMN_FORMAT_FIELD_DESC);
    oprot.writeBool(this.column_format);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(_PIXEL_RADIUS_FIELD_DESC);
    oprot.writeI32(this.pixelRadius);
    oprot.writeFieldEnd();
    if (this.nonce != null) {
      oprot.writeFieldBegin(_NONCE_FIELD_DESC);
      oprot.writeString(this.nonce);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("get_row_for_pixel_args(");

    ret.write("session:");
    if (this.session == null) {
      ret.write("null");
    } else {
      ret.write(this.session);
    }

    ret.write(", ");
    ret.write("widget_id:");
    ret.write(this.widget_id);

    ret.write(", ");
    ret.write("pixel:");
    if (this.pixel == null) {
      ret.write("null");
    } else {
      ret.write(this.pixel);
    }

    ret.write(", ");
    ret.write("table_name:");
    if (this.table_name == null) {
      ret.write("null");
    } else {
      ret.write(this.table_name);
    }

    ret.write(", ");
    ret.write("col_names:");
    if (this.col_names == null) {
      ret.write("null");
    } else {
      ret.write(this.col_names);
    }

    ret.write(", ");
    ret.write("column_format:");
    ret.write(this.column_format);

    ret.write(", ");
    ret.write("pixelRadius:");
    ret.write(this.pixelRadius);

    ret.write(", ");
    ret.write("nonce:");
    if (this.nonce == null) {
      ret.write("null");
    } else {
      ret.write(this.nonce);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class get_row_for_pixel_result implements TBase {
  static final TStruct _STRUCT_DESC = new TStruct("get_row_for_pixel_result");
  static final TField _SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, 0);
  static final TField _E_FIELD_DESC = new TField("e", TType.STRUCT, 1);

  TPixelRowResult _success;
  static const int SUCCESS = 0;
  TMapDException _e;
  static const int E = 1;


  get_row_for_pixel_result() {
  }

  // success
  TPixelRowResult get success => this._success;

  set success(TPixelRowResult success) {
    this._success = success;
  }

  bool isSetSuccess() => this.success != null;

  unsetSuccess() {
    this.success = null;
  }

  // e
  TMapDException get e => this._e;

  set e(TMapDException e) {
    this._e = e;
  }

  bool isSetE() => this.e != null;

  unsetE() {
    this.e = null;
  }

  getFieldValue(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return this.success;
      case E:
        return this.e;
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  setFieldValue(int fieldID, Object value) {
    switch (fieldID) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          this.success = value;
        }
        break;

      case E:
        if (value == null) {
          unsetE();
        } else {
          this.e = value;
        }
        break;

      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  bool isSet(int fieldID) {
    switch (fieldID) {
      case SUCCESS:
        return isSetSuccess();
      case E:
        return isSetE();
      default:
        throw new ArgumentError("Field $fieldID doesn't exist!");
    }
  }

  read(TProtocol iprot) {
    TField field;
    iprot.readStructBegin();
    while (true) {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) {
        break;
      }
      switch (field.id) {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new TPixelRowResult();
            this.success.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case E:
          if (field.type == TType.STRUCT) {
            this.e = new TMapDException();
            this.e.read(iprot);
          } else {
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  write(TProtocol oprot) {
    oprot.writeStructBegin(_STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(_SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetE()) {
      oprot.writeFieldBegin(_E_FIELD_DESC);
      this.e.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  String toString() {
    StringBuffer ret = new StringBuffer("get_row_for_pixel_result(");

    ret.write("success:");
    if (this.success == null) {
      ret.write("null");
    } else {
      ret.write(this.success);
    }

    ret.write(", ");
    ret.write("e:");
    if (this.e == null) {
      ret.write("null");
    } else {
      ret.write(this.e);
    }

    ret.write(")");

    return ret.toString();
  }

  validate() {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

